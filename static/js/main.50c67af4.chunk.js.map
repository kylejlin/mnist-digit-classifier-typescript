{"version":3,"sources":["workers/networkTester.ts","workers/networkTrainer.ts","matrix.ts","data/index.ts","workerMessages.ts","data/mnist.ts","network.ts","networkSerializer.ts","state.ts","stateSavers.ts","workers/networkTester.importable.js","workers/networkTrainer.importable.js","networkServices.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","Worker","Matrix","rows","columns","data","this","size","Array","i","Math","random","fill","length","some","row","Error","JSON","stringify","flat","entries","slice","n","other","TypeError","clone","product","zeros","thisData","otherData","productData","thisRows","otherColumns","thisColumns","productColumns","thisR","otherC","thisC","transposed","r","c","f","cloneData","decimals","entryStrings","rowMajorOrderEntries","map","entry","toFixed","entryStringLengths","s","maxLength","max","topAndBottomBorder","repeat","str","leftpad","minLength","fillCharacter","diff","Idx3FileFormat","offset","requiredValue","Idx1FileFormat","getLabeledImages","imagesBuffer","labelsBuffer","images","buffer","bytes","Uint8Array","actual","getInt32MsbFirst","expected","toString","assertIdx3MagicNumberIsCorrect","numberOfImages","imagesParsed","firstPixelIndex","vectorEntries","j","matrix","columnVector","getImages","labels","assertIdx1MagicNumberIsCorrect","numberOfLabels","firstLabelIndex","getLabels","labeledImages","inputs","label","convertLabelToVector","image","outputs","WorkerMessageType","location","self","TRAINING_IMAGES_URL","url","resolve","href","TRAINING_LABELS_URL","TEST_IMAGES_URL","TEST_LABELS_URL","trainingImagesProm","fetch","then","response","arrayBuffer","trainingLabelsProm","testImagesProm","testLabelsProm","mnistProm","Promise","all","trainingImagesBuffer","trainingLabelsBuffer","testImagesBuffer","testLabelsBuffer","training","test","Network","sizes","log","layers","weights","biases","outputLayer","inputLayer","outputLayerSize","inputLayerSize","randomUniform","push","network","trainingData","miniBatchSize","epochs","learningRate","testData","epoch","miniBatches","divideIntoMiniBatches","miniBatch","getAverageGradients","weightGradients","biasGradients","mutMultiplyScalar","mutSubtract","undefined","accuracyRate","getZeroMatricesForWeightGradients","getZeroMatricesForBiasGradients","imageGradients","getGradients","mutAdd","matrices","weightMatrix","biasMatrix","performForwardPass","weightedSums","activations","errors","lastLayerError","immutApplyElementwise","sigmaPrime","mutHadamard","getLastLayerCostDerivative","immutMultiply","immutTranspose","error","weightedSum","sigma","actualOutput","expectedOutput","immutSubtract","correctClassifications","argmax","correct","total","arr","exclMax","floor","temp","shuffle","z","exp","sigmaZ","maxIndex","value","serializeNetwork","getWeights","getBiases","entryCount","weightMatrixSize","biasMatrixSize","Float64Array","cursor","weightMatrixEntries","set","biasMatrixEntries","getEntries","numberOfBytesForSizes","Uint32Array","BYTES_PER_ELEMENT","ArrayBuffer","uints","deserializeNetwork","numberOfLayers","layerSizes","fromRowMajorOrderEntries","toArray","subarray","fromWeightsAndBiases","floats","StateType","Draggable","LocalStorageKeys","NetworkTesterWorker","NetworkTrainerWorker","trainNetwork","hyperParams","listeners","worker","addEventListener","event","message","messageType","TrainingEpochCompleteNotification","onEpochComplete","notifyListenersOfEpochCompletion","TerminateTrainingResponse","updatedNetwork","networkBuffer","onTerminate","terminate","notifyListenersOfTermination","start","StartTrainingRequest","postMessage","TerminateTrainingRequest","testNetwork","onComplete","notifyListenersOfTestingCompletion","StartTestingRequest","imageSaver","stateStr","localStorage","getItem","CustomImages","option","none","decodeBytes","byteVectors","imageBytes","u8Matrix","encodeBytes","setItem","networkSaver","NeuralNetwork","numberOfBytes","toU32","charCodeAt","code","byte","u8s","u16s","ceil","String","fromCharCode","App","props","viewImageCanvasRef","customImageInputRef","cropImageCanvasRef","state","match","mnist","stateType","CreateNetwork","hiddenLayerSizeInputValues","previousNetwork","NetworkMainMenu","React","createRef","bindMethods","window","app","onCreateNetworkClick","bind","onTrainClick","onTestClick","onViewClick","onResetClick","onBatchSizeInputValueChange","onEpochsInputValueChange","onLearningRateInputValueChange","onStartTrainingClick","onTrainerTerminate","onExitHyperParameterMenuClick","onStopTrainingClick","onTestMenuExitClick","onExitViewMenuClick","onPreviousImageClick","onNextImageClick","onCustomImageInputChange","enterCropMenu","onCropImageCanvasPointerDown","onCropImageCanvasPointerMove","onCropImageCanvasPointerUp","onShouldInvertInputChange","onDarknessThresholdChange","onCustomImageLabelInputValueChange","onDeleteCustomImageClick","onAddCustomImageClick","setState","customImages","renderCreateNetworkMenu","renderNetworkMainMenu","HyperParameterMenu","renderHyperParameterMenu","TrainingInProgress","renderTrainingInProgressMenu","Test","renderTestMenu","View","renderViewMenu","Crop","renderCropMenu","className","onClick","cancelNetworkReset","addLayerBelow","hiddenLayerIndex","layerIndex","key","type","isPositiveIntStr","onChange","e","changeLayerSizeValue","target","deleteLayer","disabled","join","batchSizeInputValue","epochsInputValue","isPositiveNumStr","learningRateInputValue","epochAccuracyRates","sort","a","b","rate","err","ok","viewedImage","getViewedImage","guess","outputActivations","maxConfidence","confidence","digit","guessDigit","viewedIndex","ref","accept","onMouseMove","onTouchMove","onMouseUp","onTouchEnd","hoveredOverDraggable","draggable","TopLeftCorner","BottomRightCorner","TopRightCorner","BottomLeftCorner","EntireSquare","onMouseDown","onTouchStart","checked","shouldInvertImage","darknessThreshold","min","step","isDigit","labelInputValue","ifSome","canvas","current","width","height","ctx","getContext","imageData","Uint8ClampedArray","lightness","ImageData","getImageData","putImageData","paintImage","adjustedCropSquare","pendingCropAdjustment","cropSquare","adjustment","applyPendingAdjustment","paintImageAndCropSquare","uploadedImage","newState","saveState","changedLayerIndex","newValue","concat","expectState","every","hiddenLayerSizes","networkTester","updateState","result","updateOrUpdater","unwrapOr","batchSize","networkTrainer","prevState","ifErr","tester","newIndex","file","input","files","reject","reader","FileReader","readAsDataURL","readFileAsDataUrl","img","document","createElement","src","getAverageDarkness","x","y","square","getLocalPointerCoordinates","rect","getBoundingClientRect","scale","localRadius","CropMenuConfig","GlobalCornerHandleRadius","optDragged","hypot","dragged","startX","startY","currentX","currentY","oldAdjustment","updatedAdjustment","getHoveredOverDraggable","updatedCropSquare","newThreshold","newImage","shouldInvert","imageSmoothingEnabled","drawImage","invertContext","srcCtx","fillStyle","fillRect","applyWhiteBackground","getU8Matrix","getCustomImage","updatedCustomImages","newImageIndex","customImageIndex","newCustomImages","Component","Number","isFinite","OverlayColor","CropSquareColor","CropSquareLineWidth","crop","clearRect","cropBottom","cropRight","paintOverlay","compressed","pixels","averageLightness","applyGrayscale","lightnessThreshold","roundedLightness","applyDarknessThreshold","cropAndCompress","paintCompressedImage","strokeStyle","lineWidth","strokeRect","drawCropSquareCircle","moveTo","beginPath","arc","PI","closePath","boundingRect","clientX","clientY","touches","getGlobalPointerCoordinates","xScale","yScale","left","top","canvasWidth","canvasHeight","preserveSize","maxX","maxY","maxSize","transformBackIntoBoundsIfNeeded","isCornerAdjustment","corner","getDiagonal","clampToTopLeft","clampToTopRight","clampToBottomRight","clampToBottomLeft","clamp","right","bottom","applyPendingCornerAdjustmentToRect","dx","dy","applyTranslation","applyPendingAdjustmentToGetPossiblyOutOfBoundsSquare","roundedDarkness","totalLightness","numberOfPixels","Boolean","hostname","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","console"],"mappings":"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","file":"static/js/main.50c67af4.chunk.js","sourcesContent":["module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"b6cf119445366dff338d.worker.js\");\n};","module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"6586aa469a69db687a96.worker.js\");\n};","export class Matrix {\n  static randomUniform(rows: number, columns: number): Matrix {\n    const size = rows * columns;\n    const data = new Array(size);\n    for (let i = 0; i < size; i++) {\n      data[i] = Math.random() * 2 - 1;\n    }\n    return new Matrix(rows, columns, data);\n  }\n\n  static zeros(rows: number, columns: number): Matrix {\n    const data = new Array(rows * columns).fill(0);\n    return new Matrix(rows, columns, data);\n  }\n\n  static fromRows(rows: number[][]): Matrix {\n    const columns = rows[0].length;\n    if (rows.some((row) => row.length !== columns)) {\n      throw new Error(\n        \"Cannot create a matrix from a jagged array: \" + JSON.stringify(rows)\n      );\n    }\n\n    return new Matrix(rows.length, columns, rows.flat());\n  }\n\n  static columnVector(entries: number[]): Matrix {\n    return new Matrix(entries.length, 1, entries);\n  }\n\n  static fromRowMajorOrderEntries(\n    rows: number,\n    columns: number,\n    entries: number[]\n  ): Matrix {\n    if (entries.length !== rows * columns) {\n      throw new Error(\n        \"Expected \" +\n          rows * columns +\n          \" entries but instead got \" +\n          entries.length +\n          \".\"\n      );\n    }\n\n    return new Matrix(rows, columns, entries);\n  }\n\n  public readonly rows: number;\n  public readonly columns: number;\n  private data: number[];\n\n  private constructor(rows: number, columns: number, data: number[]) {\n    this.rows = rows;\n    this.columns = columns;\n    this.data = data;\n  }\n\n  clone(): Matrix {\n    return new Matrix(this.rows, this.columns, this.data.slice());\n  }\n\n  mutMultiplyScalar(n: number): void {\n    const size = this.data.length;\n    for (let i = 0; i < size; i++) {\n      this.data[i] *= n;\n    }\n  }\n\n  mutAdd(other: Matrix): void {\n    if (!(other.rows === this.rows && other.columns === this.columns)) {\n      throw new TypeError(\n        \"Cannot add a \" +\n          this.rows +\n          \"x\" +\n          this.columns +\n          \" to a \" +\n          other.rows +\n          \"x\" +\n          other.columns +\n          \" matrix.\"\n      );\n    }\n\n    const size = this.data.length;\n    for (let i = 0; i < size; i++) {\n      this.data[i] += other.data[i];\n    }\n  }\n\n  mutSubtract(other: Matrix): void {\n    if (!(other.rows === this.rows && other.columns === this.columns)) {\n      throw new TypeError(\n        \"Cannot add a \" +\n          this.rows +\n          \"x\" +\n          this.columns +\n          \" to a \" +\n          other.rows +\n          \"x\" +\n          other.columns +\n          \" matrix.\"\n      );\n    }\n\n    const size = this.data.length;\n    for (let i = 0; i < size; i++) {\n      this.data[i] -= other.data[i];\n    }\n  }\n\n  immutSubtract(other: Matrix): Matrix {\n    if (!(other.rows === this.rows && other.columns === this.columns)) {\n      throw new TypeError(\n        \"Cannot add a \" +\n          this.rows +\n          \"x\" +\n          this.columns +\n          \" matrix to a \" +\n          other.rows +\n          \"x\" +\n          other.columns +\n          \" matrix.\"\n      );\n    }\n\n    const clone = this.clone();\n    const size = clone.data.length;\n    for (let i = 0; i < size; i++) {\n      clone.data[i] -= other.data[i];\n    }\n    return clone;\n  }\n\n  immutMultiply(other: Matrix): Matrix {\n    if (this.columns !== other.rows) {\n      throw new TypeError(\n        \"Cannot multiply a \" +\n          this.rows +\n          \"x\" +\n          this.columns +\n          \" matrix with a \" +\n          other.rows +\n          \"x\" +\n          other.columns +\n          \" matrix.\"\n      );\n    }\n\n    const product = Matrix.zeros(this.rows, other.columns);\n\n    const thisData = this.data;\n    const otherData = other.data;\n    const productData = product.data;\n    const thisRows = this.rows;\n    const otherColumns = other.columns;\n    const thisColumns = this.columns;\n    const productColumns = product.columns;\n\n    for (let thisR = 0; thisR < thisRows; thisR++) {\n      for (let otherC = 0; otherC < otherColumns; otherC++) {\n        for (let thisC = 0; thisC < thisColumns; thisC++) {\n          productData[thisR * productColumns + otherC] +=\n            thisData[thisR * thisColumns + thisC] *\n            otherData[thisC * otherColumns + otherC];\n        }\n      }\n    }\n    return product;\n  }\n\n  mutHadamard(other: Matrix): void {\n    if (!(other.rows === this.rows && other.columns === this.columns)) {\n      throw new TypeError(\n        \"Cannot take the Hadamard product of a \" +\n          this.rows +\n          \"x\" +\n          this.columns +\n          \" matrix and a \" +\n          other.rows +\n          \"x\" +\n          other.columns +\n          \" matrix.\"\n      );\n    }\n\n    const size = this.data.length;\n    for (let i = 0; i < size; i++) {\n      this.data[i] *= other.data[i];\n    }\n  }\n\n  immutTranspose(): Matrix {\n    const transposed = new Matrix(this.columns, this.rows, this.data.slice());\n    for (let r = 0; r < this.rows; r++) {\n      for (let c = 0; c < this.columns; c++) {\n        transposed.data[c * transposed.columns + r] = this.data[\n          r * this.columns + c\n        ];\n      }\n    }\n    return transposed;\n  }\n\n  rowMajorOrderEntries(): readonly number[] {\n    return this.data;\n  }\n\n  immutApplyElementwise(f: (entry: number) => number): Matrix {\n    const clone = this.clone();\n    const cloneData = clone.data;\n    const size = cloneData.length;\n    for (let i = 0; i < size; i++) {\n      cloneData[i] = f(cloneData[i]);\n    }\n    return clone;\n  }\n\n  print(decimals: number): string {\n    const entries = this.rowMajorOrderEntries();\n    const entryStrings = entries.map((entry) => entry.toFixed(decimals));\n    const entryStringLengths = entryStrings.map((s) => s.length);\n    const maxLength = Math.max(...entryStringLengths);\n\n    const topAndBottomBorder = \"-\".repeat(\n      this.columns * (maxLength + \" | \".length) - \" | \".length\n    );\n\n    let str = topAndBottomBorder + \"\\n\";\n\n    for (let r = 0; r < this.rows; r++) {\n      for (let c = 0; c < this.columns; c++) {\n        str +=\n          leftpad(entryStrings[r * this.columns + c], maxLength, \" \") + \" | \";\n      }\n\n      str = str.slice(0, -\" | \".length);\n\n      str += \"\\n\";\n    }\n\n    str += topAndBottomBorder;\n    return str;\n  }\n}\n\nfunction leftpad(s: string, minLength: number, fillCharacter: string): string {\n  const diff = minLength - s.length;\n  if (diff <= 0) {\n    return s;\n  }\n\n  return fillCharacter.repeat(diff) + s;\n}\n","import { Matrix } from \"../matrix\";\n\nexport interface LabeledImage {\n  rows: number;\n  columns: number;\n  inputs: Matrix;\n  label: number;\n}\n\nexport interface VectorLabeledImage {\n  rows: number;\n  columns: number;\n  inputs: Matrix;\n  outputs: Matrix;\n}\n\ninterface ImageMatrix {\n  rows: number;\n  columns: number;\n  matrix: Matrix;\n}\n\nexport interface AccuracyRate {\n  correct: number;\n  total: number;\n}\n\nconst Idx3FileFormat = {\n  MagicNumber: { offset: 0, requiredValue: 0x00000803 },\n  NumberOfImages: { offset: 4 },\n  NumberOfRows: { offset: 8 },\n  NumberOfColumns: { offset: 12 },\n} as const;\n\nconst Idx1FileFormat = {\n  MagicNumber: { offset: 0, requiredValue: 0x00000801 },\n  NumberOfLabels: { offset: 4 },\n} as const;\n\nexport function getLabeledImages(\n  imagesBuffer: ArrayBuffer,\n  labelsBuffer: ArrayBuffer\n): LabeledImage[] {\n  const images = getImages(imagesBuffer);\n  const labels = getLabels(labelsBuffer);\n\n  if (images.length !== labels.length) {\n    throw new Error(\n      \"There are \" +\n        images.length +\n        \" images, but \" +\n        labels.length +\n        \" labels. There must be the same amount of images and labels.\"\n    );\n  }\n\n  const labeledImages: LabeledImage[] = new Array(images.length);\n  for (let i = 0; i < images.length; i++) {\n    const { rows, columns, matrix } = images[i];\n    labeledImages[i] = { rows, columns, inputs: matrix, label: labels[i] };\n  }\n  return labeledImages;\n}\n\nfunction getImages(buffer: ArrayBuffer): ImageMatrix[] {\n  const bytes = new Uint8Array(buffer);\n\n  assertIdx3MagicNumberIsCorrect(bytes);\n\n  const numberOfImages = getInt32MsbFirst(\n    bytes,\n    Idx3FileFormat.NumberOfImages.offset\n  );\n  const rows = getInt32MsbFirst(bytes, Idx3FileFormat.NumberOfRows.offset);\n  const columns = getInt32MsbFirst(\n    bytes,\n    Idx3FileFormat.NumberOfColumns.offset\n  );\n  const size = rows * columns;\n\n  let imagesParsed = 0;\n  const images: ImageMatrix[] = new Array(numberOfImages);\n  const firstPixelIndex = Idx3FileFormat.NumberOfColumns.offset + 4;\n\n  while (imagesParsed < numberOfImages) {\n    const vectorEntries: number[] = new Array(size);\n    for (let j = 0; j < size; j++) {\n      vectorEntries[j] = bytes[firstPixelIndex + imagesParsed * size + j] / 255;\n    }\n\n    images[imagesParsed] = {\n      rows,\n      columns,\n      matrix: Matrix.columnVector(vectorEntries),\n    };\n    imagesParsed++;\n  }\n\n  return images;\n}\n\nfunction assertIdx3MagicNumberIsCorrect(bytes: Uint8Array): void {\n  const actual = getInt32MsbFirst(bytes, Idx3FileFormat.MagicNumber.offset);\n  const expected = Idx3FileFormat.MagicNumber.requiredValue;\n  if (actual !== expected) {\n    throw new Error(\n      \"The first 4 bytes of an idx3 file must be 0x\" +\n        expected.toString(16) +\n        \", but the first 4 bytes of the provided file were 0x\" +\n        actual.toString(16)\n    );\n  }\n}\n\nfunction getInt32MsbFirst(bytes: Uint8Array, offset: number): number {\n  return (\n    (bytes[offset] << 24) |\n    (bytes[offset + 1] << 16) |\n    (bytes[offset + 2] << 8) |\n    bytes[offset + 3]\n  );\n}\n\nfunction getLabels(buffer: ArrayBuffer): number[] {\n  const bytes = new Uint8Array(buffer);\n\n  assertIdx1MagicNumberIsCorrect(bytes);\n\n  const numberOfLabels = getInt32MsbFirst(\n    bytes,\n    Idx1FileFormat.NumberOfLabels.offset\n  );\n  const labels: number[] = new Array(numberOfLabels);\n  const firstLabelIndex = Idx1FileFormat.NumberOfLabels.offset + 4;\n  for (let i = 0; i < numberOfLabels; i++) {\n    labels[i] = bytes[firstLabelIndex + i];\n  }\n  return labels;\n}\n\nfunction assertIdx1MagicNumberIsCorrect(bytes: Uint8Array): void {\n  const actual = getInt32MsbFirst(bytes, Idx1FileFormat.MagicNumber.offset);\n  const expected = Idx1FileFormat.MagicNumber.requiredValue;\n  if (actual !== expected) {\n    throw new Error(\n      \"The first 4 bytes of an idx1 file must be 0x\" +\n        expected.toString(16) +\n        \", but the first 4 bytes of the provided file were 0x\" +\n        actual.toString(16)\n    );\n  }\n}\n\nexport function convertLabelToVector(image: LabeledImage): VectorLabeledImage {\n  const entries: number[] = new Array(10).fill(0);\n  entries[image.label] = 1;\n  const outputs = Matrix.columnVector(entries);\n  return {\n    rows: image.rows,\n    columns: image.columns,\n    inputs: image.inputs,\n    outputs,\n  };\n}\n","import { AccuracyRate } from \"./data\";\n\nexport enum WorkerMessageType {\n  StartTrainingRequest,\n  TrainingEpochCompleteNotification,\n  TerminateTrainingRequest,\n  TerminateTrainingResponse,\n\n  StartTestingRequest,\n  TestCompleteNotification,\n}\n\nexport type NetworkTrainerRequest =\n  | StartTrainingRequest\n  | TerminateTrainingRequest;\n\nexport type NetworkTrainerNotification =\n  | TrainingEpochCompleteNotification\n  | TerminateTrainingResponse;\n\nexport interface StartTrainingRequest {\n  messageType: WorkerMessageType.StartTrainingRequest;\n\n  networkBuffer: ArrayBuffer;\n  hyperParams: StochasticGradientDescentHyperParameters;\n}\n\nexport interface StochasticGradientDescentHyperParameters {\n  batchSize: number;\n  epochs: number;\n  learningRate: number;\n}\n\nexport interface TrainingEpochCompleteNotification {\n  messageType: WorkerMessageType.TrainingEpochCompleteNotification;\n\n  accuracyRate: AccuracyRate;\n  epoch: number;\n}\n\nexport interface TerminateTrainingRequest {\n  messageType: WorkerMessageType.TerminateTrainingRequest;\n}\n\nexport interface TerminateTrainingResponse {\n  messageType: WorkerMessageType.TerminateTrainingResponse;\n\n  networkBuffer: ArrayBuffer;\n}\n\nexport interface StartTestingRequest {\n  messageType: WorkerMessageType.StartTestingRequest;\n\n  networkBuffer: ArrayBuffer;\n}\n\nexport interface TestCompleteNotification {\n  messageType: WorkerMessageType.TestCompleteNotification;\n  accuracyRate: AccuracyRate;\n}\n","import url from \"url\";\nimport {\n  convertLabelToVector,\n  getLabeledImages,\n  LabeledImage,\n  VectorLabeledImage,\n} from \".\";\n\nexport interface MnistData {\n  training: VectorLabeledImage[];\n  test: LabeledImage[];\n}\n\ndeclare const self: { location: Window[\"location\"] };\n\nconst { location } = self;\n\nconst TRAINING_IMAGES_URL = url.resolve(\n  location.href,\n  \"./assets/train60k-images-idx3-ubyte\"\n);\nconst TRAINING_LABELS_URL = url.resolve(\n  location.href,\n  \"./assets/train60k-labels-idx1-ubyte\"\n);\nconst TEST_IMAGES_URL = url.resolve(\n  location.href,\n  \"./assets/test10k-images-idx3-ubyte\"\n);\nconst TEST_LABELS_URL = url.resolve(\n  location.href,\n  \"./assets/test10k-labels-idx1-ubyte\"\n);\nconst trainingImagesProm: Promise<ArrayBuffer> = fetch(\n  TRAINING_IMAGES_URL\n).then((response) => response.arrayBuffer());\nconst trainingLabelsProm: Promise<ArrayBuffer> = fetch(\n  TRAINING_LABELS_URL\n).then((response) => response.arrayBuffer());\nconst testImagesProm: Promise<ArrayBuffer> = fetch(\n  TEST_IMAGES_URL\n).then((response) => response.arrayBuffer());\nconst testLabelsProm: Promise<ArrayBuffer> = fetch(\n  TEST_LABELS_URL\n).then((response) => response.arrayBuffer());\n\nexport const mnistProm: Promise<MnistData> = Promise.all([\n  trainingImagesProm,\n  trainingLabelsProm,\n  testImagesProm,\n  testLabelsProm,\n]).then(\n  ([\n    trainingImagesBuffer,\n    trainingLabelsBuffer,\n    testImagesBuffer,\n    testLabelsBuffer,\n  ]) => {\n    return {\n      training: getLabeledImages(\n        trainingImagesBuffer,\n        trainingLabelsBuffer\n      ).map(convertLabelToVector),\n      test: getLabeledImages(testImagesBuffer, testLabelsBuffer),\n    };\n  }\n);\n","import { LabeledImage, VectorLabeledImage, AccuracyRate } from \"./data\";\nimport { Matrix } from \"./matrix\";\nimport { DeepReadonly } from \"./deepReadonly\";\n\nexport class Network {\n  private layers: number;\n  private weights: MatrixMap;\n  private biases: MatrixMap;\n  private log: (accuracyRate: AccuracyRate, epoch: number) => void;\n\n  public readonly sizes: number[];\n\n  static fromWeightsAndBiases(weights: MatrixMap, biases: MatrixMap): Network {\n    const sizes = [weights[1].columns];\n    for (let i = 1; i < weights.length; i++) {\n      sizes.push(weights[i].rows);\n    }\n\n    const network = new Network(sizes);\n\n    for (let i = 1; i < weights.length; i++) {\n      network.weights[i] = weights[i];\n      network.biases[i] = biases[i];\n    }\n\n    return network;\n  }\n\n  constructor(\n    sizes: number[],\n    log?: (accuracyRate: AccuracyRate, epoch: number) => void\n  ) {\n    this.layers = sizes.length;\n\n    this.weights = [];\n    this.biases = [];\n    for (let outputLayer = 1; outputLayer < sizes.length; outputLayer++) {\n      const inputLayer = outputLayer - 1;\n      const outputLayerSize = sizes[outputLayer];\n      const inputLayerSize = sizes[inputLayer];\n      this.weights[outputLayer] = Matrix.randomUniform(\n        outputLayerSize,\n        inputLayerSize\n      );\n      this.biases[outputLayer] = Matrix.randomUniform(outputLayerSize, 1);\n    }\n\n    this.log = log || (() => {});\n\n    this.sizes = sizes;\n  }\n\n  stochasticGradientDescent(\n    trainingData: VectorLabeledImage[],\n    miniBatchSize: number,\n    epochs: number,\n    learningRate: number,\n    testData?: LabeledImage[]\n  ): void {\n    for (let epoch = 0; epoch < epochs; epoch++) {\n      const miniBatches = divideIntoMiniBatches(trainingData, miniBatchSize);\n      for (const miniBatch of miniBatches) {\n        const { weightGradients, biasGradients } = this.getAverageGradients(\n          miniBatch\n        );\n\n        for (let i = 1; i < this.layers; i++) {\n          weightGradients[i].mutMultiplyScalar(learningRate);\n          biasGradients[i].mutMultiplyScalar(learningRate);\n\n          this.weights[i].mutSubtract(weightGradients[i]);\n          this.biases[i].mutSubtract(biasGradients[i]);\n        }\n      }\n\n      if (testData !== undefined) {\n        const accuracyRate = this.test(testData);\n        this.log(accuracyRate, epoch);\n      }\n    }\n  }\n\n  private getAverageGradients(miniBatch: VectorLabeledImage[]): Gradients {\n    const weightGradients = this.getZeroMatricesForWeightGradients();\n    const biasGradients = this.getZeroMatricesForBiasGradients();\n\n    for (const image of miniBatch) {\n      const imageGradients = this.getGradients(image);\n      for (let i = 1; i < this.layers; i++) {\n        weightGradients[i].mutAdd(imageGradients.weightGradients[i]);\n        biasGradients[i].mutAdd(imageGradients.biasGradients[i]);\n      }\n    }\n\n    for (let i = 1; i < this.layers; i++) {\n      weightGradients[i].mutMultiplyScalar(1 / miniBatch.length);\n      biasGradients[i].mutMultiplyScalar(1 / miniBatch.length);\n    }\n\n    return { weightGradients, biasGradients };\n  }\n\n  private getZeroMatricesForWeightGradients(): MatrixMap {\n    const matrices: MatrixMap = [];\n    for (let i = 1; i < this.layers; i++) {\n      const weightMatrix = this.weights[i];\n      matrices[i] = Matrix.zeros(weightMatrix.rows, weightMatrix.columns);\n    }\n    return matrices;\n  }\n\n  private getZeroMatricesForBiasGradients(): MatrixMap {\n    const matrices: MatrixMap = [];\n    for (let i = 1; i < this.layers; i++) {\n      const biasMatrix = this.biases[i];\n      matrices[i] = Matrix.zeros(biasMatrix.rows, biasMatrix.columns);\n    }\n    return matrices;\n  }\n\n  private getGradients(image: VectorLabeledImage): Gradients {\n    const { weightedSums, activations } = this.performForwardPass(image.inputs);\n    const errors: MatrixMap = [];\n    const weightGradients: MatrixMap = [];\n    const biasGradients: MatrixMap = [];\n\n    const lastLayerError = weightedSums[this.layers - 1].immutApplyElementwise(\n      sigmaPrime\n    );\n    lastLayerError.mutHadamard(\n      this.getLastLayerCostDerivative(\n        activations[this.layers - 1],\n        image.outputs\n      )\n    );\n\n    errors[this.layers - 1] = lastLayerError;\n    weightGradients[this.layers - 1] = lastLayerError.immutMultiply(\n      activations[this.layers - 2].immutTranspose()\n    );\n    biasGradients[this.layers - 1] = lastLayerError;\n\n    for (let i = this.layers - 2; i >= 1; i--) {\n      const error = this.weights[i + 1]\n        .immutTranspose()\n        .immutMultiply(errors[i + 1]);\n      error.mutHadamard(weightedSums[i].immutApplyElementwise(sigmaPrime));\n\n      errors[i] = error;\n      weightGradients[i] = error.immutMultiply(\n        activations[i - 1].immutTranspose()\n      );\n      biasGradients[i] = error;\n    }\n\n    return { weightGradients, biasGradients };\n  }\n\n  performForwardPass(inputs: Matrix): WeightedSumsAndActivations {\n    const weightedSums: MatrixMap = [];\n    const activations: MatrixMap = [inputs];\n\n    for (let outputLayer = 1; outputLayer < this.layers; outputLayer++) {\n      const inputLayer = outputLayer - 1;\n      const weightedSum = this.weights[outputLayer].immutMultiply(\n        activations[inputLayer]\n      );\n      weightedSum.mutAdd(this.biases[outputLayer]);\n      weightedSums[outputLayer] = weightedSum;\n      activations[outputLayer] = weightedSum.immutApplyElementwise(sigma);\n    }\n    return { weightedSums, activations };\n  }\n\n  private getLastLayerCostDerivative(\n    actualOutput: Matrix,\n    expectedOutput: Matrix\n  ): Matrix {\n    return actualOutput.immutSubtract(expectedOutput);\n  }\n\n  test(testData: LabeledImage[]): AccuracyRate {\n    let correctClassifications = 0;\n    for (const image of testData) {\n      const { activations } = this.performForwardPass(image.inputs);\n      const prediction = argmax(\n        activations[this.layers - 1].rowMajorOrderEntries()\n      );\n      if (prediction === image.label) {\n        correctClassifications++;\n      }\n    }\n    return { correct: correctClassifications, total: testData.length };\n  }\n\n  getWeights(): DeepReadonly<MatrixMap> {\n    return this.weights;\n  }\n\n  getBiases(): DeepReadonly<MatrixMap> {\n    return this.biases;\n  }\n}\n\nexport interface MatrixMap {\n  [layer: number]: Matrix;\n  length: number;\n}\n\nexport interface Gradients {\n  weightGradients: MatrixMap;\n  biasGradients: MatrixMap;\n}\n\nexport interface WeightedSumsAndActivations {\n  weightedSums: MatrixMap;\n  activations: MatrixMap;\n}\n\nfunction divideIntoMiniBatches(\n  trainingData: VectorLabeledImage[],\n  miniBatchSize: number\n): VectorLabeledImage[][] {\n  shuffle(trainingData);\n  const miniBatches: VectorLabeledImage[][] = [];\n  for (let i = 0; i < trainingData.length; i += miniBatchSize) {\n    miniBatches.push(trainingData.slice(i, i + miniBatchSize));\n  }\n  return miniBatches;\n}\n\nfunction shuffle(arr: unknown[]): void {\n  const SHUFFLE_TIMES = 512;\n\n  for (let n = 0; n < SHUFFLE_TIMES; n++) {\n    for (let i = arr.length - 1; i >= 1; i--) {\n      let j = randInt(i + 1);\n      const temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n    }\n  }\n}\n\nfunction randInt(exclMax: number): number {\n  return Math.floor(Math.random() * exclMax);\n}\n\nfunction sigma(z: number): number {\n  return 1 / (1 + Math.exp(-z));\n}\n\nfunction sigmaPrime(z: number): number {\n  const sigmaZ = sigma(z);\n  return sigmaZ * (1 - sigmaZ);\n}\n\nfunction argmax(arr: readonly number[]): number {\n  let maxIndex = 0;\n  let max = arr[maxIndex];\n  for (let i = 1; i < arr.length; i++) {\n    const value = arr[i];\n    if (value > max) {\n      max = value;\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n}\n","import { Network, MatrixMap } from \"./network\";\nimport { Matrix } from \"./matrix\";\n\nexport function serializeNetwork(network: Network): ArrayBuffer {\n  const entries = getEntries(network);\n\n  const numberOfBytesForSizes =\n    (1 + network.sizes.length) * Uint32Array.BYTES_PER_ELEMENT;\n\n  const buffer = new ArrayBuffer(\n    numberOfBytesForSizes + entries.length * entries.BYTES_PER_ELEMENT\n  );\n\n  const uints = new Uint32Array(\n    buffer,\n    0,\n    numberOfBytesForSizes / Uint32Array.BYTES_PER_ELEMENT\n  );\n\n  uints[0] = network.sizes.length;\n\n  for (let i = 0; i < network.sizes.length; i++) {\n    uints[1 + i] = network.sizes[i];\n  }\n\n  const floats = new Float64Array(buffer, numberOfBytesForSizes);\n  floats.set(entries);\n\n  return buffer;\n}\n\nfunction getEntries(network: Network): Float64Array {\n  const weights = network.getWeights();\n  const biases = network.getBiases();\n\n  let entryCount = 0;\n\n  for (let i = 1; i < weights.length; i++) {\n    const weightMatrix = weights[i];\n    const weightMatrixSize = weightMatrix.rows * weightMatrix.columns;\n    entryCount += weightMatrixSize;\n\n    const biasMatrix = biases[i];\n    const biasMatrixSize = biasMatrix.rows * biasMatrix.columns;\n    entryCount += biasMatrixSize;\n  }\n\n  const entries = new Float64Array(entryCount);\n\n  let cursor = 0;\n  for (let i = 1; i < weights.length; i++) {\n    const weightMatrixEntries = weights[i].rowMajorOrderEntries();\n    entries.set(weightMatrixEntries, cursor);\n    cursor += weightMatrixEntries.length;\n\n    const biasMatrixEntries = biases[i].rowMajorOrderEntries();\n    entries.set(biasMatrixEntries, cursor);\n    cursor += biasMatrixEntries.length;\n  }\n\n  return entries;\n}\n\nexport function deserializeNetwork(buffer: ArrayBuffer): Network {\n  const numberOfLayers = new Uint32Array(buffer, 0, 1)[0];\n  const layerSizes = new Uint32Array(buffer, 4, numberOfLayers);\n  const entries = new Float64Array(\n    buffer.slice(Uint32Array.BYTES_PER_ELEMENT * (1 + numberOfLayers))\n  );\n\n  const weights: MatrixMap = [];\n  const biases: MatrixMap = [];\n\n  let cursor = 0;\n  for (let i = 1; i < layerSizes.length; i++) {\n    const outputLayerSize = layerSizes[i];\n    const inputLayerSize = layerSizes[i - 1];\n\n    {\n      const rows = outputLayerSize;\n      const columns = inputLayerSize;\n      const size = rows * columns;\n      weights[i] = Matrix.fromRowMajorOrderEntries(\n        rows,\n        columns,\n        toArray(entries.subarray(cursor, cursor + size))\n      );\n\n      cursor += size;\n    }\n\n    {\n      const rows = outputLayerSize;\n      biases[i] = Matrix.fromRowMajorOrderEntries(\n        rows,\n        1,\n        toArray(entries.subarray(cursor, cursor + rows))\n      );\n\n      cursor += rows;\n    }\n  }\n\n  return Network.fromWeightsAndBiases(weights, biases);\n}\n\nfunction toArray(floats: Float64Array): number[] {\n  const arr = new Array(floats.length);\n  for (let i = 0; i < floats.length; i++) {\n    arr[i] = floats[i];\n  }\n  return arr;\n}\n","import { Option, Result } from \"rusty-ts\";\nimport { AccuracyRate } from \"./data\";\nimport { MnistData } from \"./data/mnist\";\nimport { Network } from \"./network\";\nimport { NetworkTester, NetworkTrainer } from \"./networkServices\";\nimport { Matrix } from \"./matrix\";\n\nexport type AppState =\n  | CreateNetworkState\n  | NetworkMainMenuState\n  | HyperParameterMenuState\n  | TrainingInProgressState\n  | TestState\n  | ViewState\n  | CropState;\n\nexport enum StateType {\n  CreateNetwork,\n  NetworkMainMenu,\n  HyperParameterMenu,\n  TrainingInProgress,\n  Test,\n  View,\n  Crop,\n}\n\nexport interface StateMap {\n  [StateType.CreateNetwork]: CreateNetworkState;\n  [StateType.NetworkMainMenu]: NetworkMainMenuState;\n  [StateType.HyperParameterMenu]: HyperParameterMenuState;\n  [StateType.TrainingInProgress]: TrainingInProgressState;\n  [StateType.Test]: TestState;\n  [StateType.View]: ViewState;\n  [StateType.Crop]: CropState;\n}\n\nexport interface CreateNetworkState {\n  mnist: Option<MnistData>;\n\n  stateType: StateType.CreateNetwork;\n\n  hiddenLayerSizeInputValues: string[];\n  previousNetwork: Option<Network>;\n}\n\nexport interface NetworkMainMenuState {\n  mnist: Option<MnistData>;\n\n  stateType: StateType.NetworkMainMenu;\n\n  network: Network;\n}\n\nexport interface HyperParameterMenuState {\n  mnist: Option<MnistData>;\n\n  stateType: StateType.HyperParameterMenu;\n\n  network: Network;\n\n  batchSizeInputValue: string;\n  epochsInputValue: string;\n  learningRateInputValue: string;\n}\n\nexport interface TrainingInProgressState {\n  mnist: Option<MnistData>;\n\n  stateType: StateType.TrainingInProgress;\n\n  network: Network;\n\n  networkTrainer: NetworkTrainer;\n  epochAccuracyRates: EpochAccuracyRate[];\n}\n\nexport interface EpochAccuracyRate extends AccuracyRate {\n  epoch: number;\n}\n\nexport interface TestState {\n  mnist: Option<MnistData>;\n\n  stateType: StateType.Test;\n\n  network: Network;\n\n  accuracyRate: Result<AccuracyRate, NetworkTester>;\n}\n\nexport interface ViewState {\n  mnist: Option<MnistData>;\n\n  stateType: StateType.View;\n\n  network: Network;\n\n  viewedIndex: number;\n  customImages: CustomImage[];\n}\n\nexport interface CustomImage {\n  u8Matrix: Matrix;\n  label: number;\n}\n\nexport interface CropState {\n  mnist: Option<MnistData>;\n\n  stateType: StateType.Crop;\n\n  network: Network;\n  customImages: CustomImage[];\n\n  uploadedImage: HTMLImageElement;\n  darknessThreshold: number;\n  cropSquare: Square;\n  pendingCropAdjustment: Option<SquareAdjustment>;\n  hoveredOverDraggable: Option<Draggable>;\n  shouldInvertImage: boolean;\n  labelInputValue: string;\n}\n\nexport interface Square {\n  x: number;\n  y: number;\n  size: number;\n}\n\nexport interface SquareAdjustment {\n  dragged: Draggable;\n  startX: number;\n  startY: number;\n  currentX: number;\n  currentY: number;\n}\n\nexport enum Draggable {\n  TopLeftCorner,\n  TopRightCorner,\n  BottomRightCorner,\n  BottomLeftCorner,\n\n  EntireSquare,\n}\n\nexport type Corner =\n  | Draggable.TopLeftCorner\n  | Draggable.TopRightCorner\n  | Draggable.BottomRightCorner\n  | Draggable.BottomLeftCorner;\n","import { Option, option } from \"rusty-ts\";\nimport { Matrix } from \"./matrix\";\nimport { Network } from \"./network\";\nimport { CustomImage } from \"./state\";\nimport { deserializeNetwork, serializeNetwork } from \"./networkSerializer\";\n\nexport interface StateSaver<T> {\n  getState(): Option<T>;\n  saveState(state: T): void;\n}\n\nenum LocalStorageKeys {\n  CustomImages = \"CustomImages\",\n  NeuralNetwork = \"NeuralNetwork\",\n}\n\n// 28*28 pixels plus 1 label\nconst BYTES_PER_IMAGE = 28 * 28 + 1;\n\nexport const imageSaver: StateSaver<CustomImage[]> = {\n  getState(): Option<CustomImage[]> {\n    const stateStr = localStorage.getItem(LocalStorageKeys.CustomImages);\n    if (stateStr === null) {\n      return option.none();\n    } else {\n      const bytes = decodeBytes(stateStr);\n\n      if (bytes.length % BYTES_PER_IMAGE !== 0) {\n        throw new Error(\n          \"Cannot decode image bytes because there are \" +\n            bytes.length +\n            \" bytes, and that number is not a multiple of 784.\"\n        );\n      }\n\n      const numberOfImages = bytes.length / BYTES_PER_IMAGE;\n\n      const byteVectors: CustomImage[] = new Array(numberOfImages);\n      for (let i = 0; i < numberOfImages; i++) {\n        const imageBytes = bytes.subarray(\n          i * BYTES_PER_IMAGE,\n          i * BYTES_PER_IMAGE + 784\n        );\n        const u8Matrix = Matrix.columnVector(toArray(imageBytes));\n        byteVectors[i] = { u8Matrix, label: bytes[i * BYTES_PER_IMAGE + 784] };\n      }\n      return option.some(byteVectors);\n    }\n  },\n\n  saveState(images: CustomImage[]): void {\n    const bytes = new Uint8Array(images.length * BYTES_PER_IMAGE);\n    for (let i = 0; i < images.length; i++) {\n      const image = images[i];\n      bytes.set(image.u8Matrix.rowMajorOrderEntries(), i * BYTES_PER_IMAGE);\n      bytes[i * BYTES_PER_IMAGE + 784] = image.label;\n    }\n\n    const stateStr = encodeBytes(bytes);\n    localStorage.setItem(LocalStorageKeys.CustomImages, stateStr);\n  },\n};\n\nexport const networkSaver: StateSaver<Network> = {\n  getState(): Option<Network> {\n    const stateStr = localStorage.getItem(LocalStorageKeys.NeuralNetwork);\n    if (stateStr === null) {\n      return option.none();\n    } else {\n      const bytes = decodeBytes(stateStr);\n      const network = deserializeNetwork(bytes.buffer);\n      return option.some(network);\n    }\n  },\n\n  saveState(network: Network): void {\n    const buffer = serializeNetwork(network);\n    const stateStr = encodeBytes(new Uint8Array(buffer));\n    localStorage.setItem(LocalStorageKeys.NeuralNetwork, stateStr);\n  },\n};\n\nfunction decodeBytes(str: string): Uint8Array {\n  const numberOfBytes = toU32((str.charCodeAt(0) << 16) | str.charCodeAt(1));\n  const bytes = new Uint8Array(numberOfBytes);\n\n  for (let i = 0; i < numberOfBytes; i++) {\n    const code = str.charCodeAt(2 + Math.floor(i / 2));\n\n    const byte = i % 2 === 0 ? code >>> 8 : code;\n\n    bytes[i] = byte;\n  }\n  return bytes;\n}\n\nfunction toU32(n: number): number {\n  const arr = new Uint32Array(1);\n  arr[0] = n;\n  return arr[0];\n}\n\nfunction toArray(u8s: Uint8Array): number[] {\n  const arr: number[] = new Array(u8s.length);\n  for (let i = 0; i < u8s.length; i++) {\n    arr[i] = u8s[i];\n  }\n  return arr;\n}\n\nfunction encodeBytes(bytes: Uint8Array): string {\n  const numberOfBytes = bytes.length;\n  const u16s = new Array(Math.ceil(numberOfBytes / 2));\n\n  for (let i = 0; i < bytes.length; i++) {\n    const byte = bytes[i];\n    if (i % 2 === 0) {\n      u16s[i / 2] = byte << 8;\n    } else {\n      u16s[(i - 1) / 2] |= byte;\n    }\n  }\n\n  return String.fromCharCode(\n    numberOfBytes >>> 16,\n    numberOfBytes & 0b0000_0000_0000_0000_1111_1111_1111_1111,\n    ...u16s\n  );\n}\n","// eslint-disable-next-line import/no-webpack-loader-syntax\nimport NetworkTesterWorker from \"worker-loader!./networkTester\";\n\nexport default NetworkTesterWorker;\n","// eslint-disable-next-line import/no-webpack-loader-syntax\nimport NetworkTrainerWorker from \"worker-loader!./networkTrainer\";\n\nexport default NetworkTrainerWorker;\n","import { AccuracyRate } from \"./data\";\nimport { Network } from \"./network\";\nimport { deserializeNetwork, serializeNetwork } from \"./networkSerializer\";\nimport {\n  NetworkTrainerNotification,\n  StartTestingRequest,\n  StartTrainingRequest,\n  StochasticGradientDescentHyperParameters,\n  TerminateTrainingRequest,\n  TerminateTrainingResponse,\n  TestCompleteNotification,\n  TrainingEpochCompleteNotification,\n  WorkerMessageType,\n} from \"./workerMessages\";\nimport NetworkTesterWorker from \"./workers/networkTester.importable\";\nimport NetworkTrainerWorker from \"./workers/networkTrainer.importable\";\n\nexport interface NetworkTrainer {\n  start(): void;\n  terminate(): void;\n}\n\nexport interface NetworkTester {\n  start(): void;\n  terminate(): void;\n}\n\nexport interface NetworkTrainerListeners {\n  onEpochComplete(accuracyRate: AccuracyRate, epoch: number): void;\n  onTerminate(network: Network): void;\n}\n\nexport interface NetworkTesterListeners {\n  onComplete(rate: AccuracyRate): void;\n}\n\nexport function trainNetwork(\n  network: Network,\n  hyperParams: StochasticGradientDescentHyperParameters,\n  listeners: NetworkTrainerListeners\n): NetworkTrainer {\n  const worker = new NetworkTrainerWorker();\n\n  worker.addEventListener(\"message\", (event) => {\n    const { data } = event;\n    if (data !== null && \"object\" === typeof data && \"messageType\" in data) {\n      const message: NetworkTrainerNotification = data;\n      switch (message.messageType) {\n        case WorkerMessageType.TrainingEpochCompleteNotification:\n          notifyListenersOfEpochCompletion(message);\n          break;\n        case WorkerMessageType.TerminateTrainingResponse:\n          notifyListenersOfTermination(message);\n          break;\n\n        default: {\n          // Force exhaustive matching\n\n          // eslint-disable-next-line\n          const unreachable: never = message;\n        }\n      }\n    }\n  });\n\n  return { start: startTraining, terminate: stopTrainingAfterThisEpoch };\n\n  function notifyListenersOfEpochCompletion(\n    message: TrainingEpochCompleteNotification\n  ): void {\n    listeners.onEpochComplete(message.accuracyRate, message.epoch);\n  }\n\n  function notifyListenersOfTermination(\n    message: TerminateTrainingResponse\n  ): void {\n    const updatedNetwork = deserializeNetwork(message.networkBuffer);\n    listeners.onTerminate(updatedNetwork);\n\n    worker.terminate();\n  }\n\n  function startTraining(): void {\n    const message: StartTrainingRequest = {\n      messageType: WorkerMessageType.StartTrainingRequest,\n      networkBuffer: serializeNetwork(network),\n      hyperParams,\n    };\n    worker.postMessage(message, [message.networkBuffer]);\n  }\n\n  function stopTrainingAfterThisEpoch(): void {\n    const message: TerminateTrainingRequest = {\n      messageType: WorkerMessageType.TerminateTrainingRequest,\n    };\n    worker.postMessage(message);\n  }\n}\n\nexport function testNetwork(\n  network: Network,\n  listeners: NetworkTesterListeners\n): NetworkTrainer {\n  const worker = new NetworkTesterWorker();\n\n  worker.addEventListener(\"message\", (event) => {\n    const { data } = event;\n    if (data !== null && \"object\" === typeof data && \"messageType\" in data) {\n      const message: TestCompleteNotification = data;\n      notifyListenersOfTestingCompletion(message);\n    }\n  });\n\n  return { start: startTesting, terminate: terminateWorker };\n\n  function notifyListenersOfTestingCompletion(\n    message: TestCompleteNotification\n  ): void {\n    listeners.onComplete(message.accuracyRate);\n\n    worker.terminate();\n  }\n\n  function startTesting(): void {\n    const message: StartTestingRequest = {\n      messageType: WorkerMessageType.StartTestingRequest,\n      networkBuffer: serializeNetwork(network),\n    };\n    worker.postMessage(message, [message.networkBuffer]);\n  }\n\n  function terminateWorker(): void {\n    worker.terminate();\n  }\n}\n","import React from \"react\";\nimport { option, Option, result } from \"rusty-ts\";\nimport \"./App.css\";\nimport { AccuracyRate, LabeledImage } from \"./data\";\nimport { MnistData, mnistProm } from \"./data/mnist\";\nimport { Matrix } from \"./matrix\";\nimport { Network } from \"./network\";\nimport { testNetwork, trainNetwork } from \"./networkServices\";\nimport {\n  AppState,\n  CreateNetworkState,\n  CropState,\n  CustomImage,\n  Draggable,\n  HyperParameterMenuState,\n  NetworkMainMenuState,\n  Square,\n  StateMap,\n  StateType,\n  TestState,\n  TrainingInProgressState,\n  ViewState,\n  SquareAdjustment,\n  Corner,\n} from \"./state\";\nimport { imageSaver, networkSaver } from \"./stateSavers\";\nimport { StochasticGradientDescentHyperParameters } from \"./workerMessages\";\n\ninterface Rect {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\ninterface CornerAdjustment extends SquareAdjustment {\n  dragged: Corner;\n}\n\nexport default class App extends React.Component<{}, AppState> {\n  private viewImageCanvasRef: React.RefObject<HTMLCanvasElement>;\n  private customImageInputRef: React.RefObject<HTMLInputElement>;\n  private cropImageCanvasRef: React.RefObject<HTMLCanvasElement>;\n\n  constructor(props: {}) {\n    super(props);\n\n    this.state = getInitialState();\n\n    this.viewImageCanvasRef = React.createRef();\n    this.customImageInputRef = React.createRef();\n    this.cropImageCanvasRef = React.createRef();\n\n    this.bindMethods();\n\n    (window as any).app = this;\n  }\n\n  bindMethods(): void {\n    this.onCreateNetworkClick = this.onCreateNetworkClick.bind(this);\n    this.onTrainClick = this.onTrainClick.bind(this);\n    this.onTestClick = this.onTestClick.bind(this);\n    this.onViewClick = this.onViewClick.bind(this);\n    this.onResetClick = this.onResetClick.bind(this);\n    this.onBatchSizeInputValueChange = this.onBatchSizeInputValueChange.bind(\n      this\n    );\n    this.onEpochsInputValueChange = this.onEpochsInputValueChange.bind(this);\n    this.onLearningRateInputValueChange = this.onLearningRateInputValueChange.bind(\n      this\n    );\n    this.onStartTrainingClick = this.onStartTrainingClick.bind(this);\n    this.onEpochComplete = this.onEpochComplete.bind(this);\n    this.onTrainerTerminate = this.onTrainerTerminate.bind(this);\n    this.onExitHyperParameterMenuClick = this.onExitHyperParameterMenuClick.bind(\n      this\n    );\n    this.onStopTrainingClick = this.onStopTrainingClick.bind(this);\n    this.onTestMenuExitClick = this.onTestMenuExitClick.bind(this);\n    this.onExitViewMenuClick = this.onExitViewMenuClick.bind(this);\n    this.onPreviousImageClick = this.onPreviousImageClick.bind(this);\n    this.onNextImageClick = this.onNextImageClick.bind(this);\n    this.onCustomImageInputChange = this.onCustomImageInputChange.bind(this);\n    this.enterCropMenu = this.enterCropMenu.bind(this);\n    this.onCropImageCanvasPointerDown = this.onCropImageCanvasPointerDown.bind(\n      this\n    );\n    this.onCropImageCanvasPointerMove = this.onCropImageCanvasPointerMove.bind(\n      this\n    );\n    this.onCropImageCanvasPointerUp = this.onCropImageCanvasPointerUp.bind(\n      this\n    );\n    this.onShouldInvertInputChange = this.onShouldInvertInputChange.bind(this);\n    this.onDarknessThresholdChange = this.onDarknessThresholdChange.bind(this);\n    this.onCustomImageLabelInputValueChange = this.onCustomImageLabelInputValueChange.bind(\n      this\n    );\n    this.onDeleteCustomImageClick = this.onDeleteCustomImageClick.bind(this);\n    this.onAddCustomImageClick = this.onAddCustomImageClick.bind(this);\n  }\n\n  componentDidMount(): void {\n    mnistProm.then((mnist) => {\n      this.setState({ mnist: option.some(mnist) });\n    });\n  }\n\n  saveState(state: AppState): void {\n    this.setState(state);\n\n    if (\"network\" in state) {\n      const { network } = state;\n      networkSaver.saveState(network);\n    }\n\n    if (\"customImages\" in state) {\n      const { customImages } = state;\n      imageSaver.saveState(customImages);\n    }\n  }\n\n  render(): React.ReactElement {\n    const { state } = this;\n    switch (state.stateType) {\n      case StateType.CreateNetwork:\n        return this.renderCreateNetworkMenu(state);\n      case StateType.NetworkMainMenu:\n        return this.renderNetworkMainMenu(state);\n      case StateType.HyperParameterMenu:\n        return this.renderHyperParameterMenu(state);\n      case StateType.TrainingInProgress:\n        return this.renderTrainingInProgressMenu(state);\n      case StateType.Test:\n        return this.renderTestMenu(state);\n      case StateType.View:\n        return this.renderViewMenu(state);\n      case StateType.Crop:\n        return this.renderCropMenu(state);\n    }\n  }\n\n  renderCreateNetworkMenu(state: CreateNetworkState): React.ReactElement {\n    return (\n      <div className=\"App\">\n        <h1>\n          {state.previousNetwork.match({\n            none: () => \"Create network\",\n            some: () => \"Reset network\",\n          })}\n        </h1>\n\n        {state.previousNetwork.match({\n          none: () => null,\n          some: (network) => (\n            <button onClick={() => this.cancelNetworkReset(network)}>\n              Cancel\n            </button>\n          ),\n        })}\n\n        <h2>Layers:</h2>\n        <ol>\n          <li>\n            Input layer: 784 neurons\n            <button onClick={() => this.addLayerBelow(0, state)}>\n              Add layer below\n            </button>\n          </li>\n\n          {state.hiddenLayerSizeInputValues.map((value, hiddenLayerIndex) => {\n            const layerIndex = hiddenLayerIndex + 1;\n            return (\n              <li key={layerIndex}>\n                <label>\n                  Hidden layer:{\" \"}\n                  <input\n                    type=\"text\"\n                    className={isPositiveIntStr(value) ? \"\" : \"InvalidInput\"}\n                    value={value}\n                    onChange={(e) =>\n                      this.changeLayerSizeValue(\n                        layerIndex,\n                        e.target.value,\n                        state\n                      )\n                    }\n                  />{\" \"}\n                  neurons\n                </label>\n                <button onClick={() => this.addLayerBelow(layerIndex, state)}>\n                  Add layer below\n                </button>\n                <button onClick={() => this.deleteLayer(layerIndex, state)}>\n                  Delete layer\n                </button>\n              </li>\n            );\n          })}\n\n          <li>Output layer: 10 neurons</li>\n        </ol>\n\n        <button\n          onClick={this.onCreateNetworkClick}\n          disabled={state.hiddenLayerSizeInputValues.some(\n            (value) => !isPositiveIntStr(value)\n          )}\n        >\n          Create network\n        </button>\n      </div>\n    );\n  }\n\n  renderNetworkMainMenu(state: NetworkMainMenuState): React.ReactElement {\n    return (\n      <div className=\"App\">\n        <h1>Explore your neural network</h1>\n        <h2>Neurons in each layer: {state.network.sizes.join(\", \")}</h2>\n\n        <button onClick={this.onTrainClick}>Train</button>\n        <button onClick={this.onTestClick}>Test</button>\n        <button onClick={this.onViewClick}>View</button>\n        <button onClick={this.onResetClick}>Reset</button>\n      </div>\n    );\n  }\n\n  renderHyperParameterMenu(state: HyperParameterMenuState): React.ReactElement {\n    return (\n      <div className=\"App\">\n        <h1>Train (stochastic gradient descent)</h1>\n\n        <button onClick={this.onExitHyperParameterMenuClick}>Cancel</button>\n\n        <h2>Hyperparameters:</h2>\n\n        <label>\n          Batch size:{\" \"}\n          <input\n            type=\"text\"\n            className={\n              isPositiveIntStr(state.batchSizeInputValue) ? \"\" : \"InvalidInput\"\n            }\n            value={state.batchSizeInputValue}\n            onChange={this.onBatchSizeInputValueChange}\n          />\n        </label>\n\n        <label>\n          Epochs:{\" \"}\n          <input\n            type=\"text\"\n            className={\n              isPositiveIntStr(state.epochsInputValue) ? \"\" : \"InvalidInput\"\n            }\n            value={state.epochsInputValue}\n            onChange={this.onEpochsInputValueChange}\n          />\n        </label>\n\n        <label>\n          Learning rate:{\" \"}\n          <input\n            type=\"text\"\n            className={\n              isPositiveNumStr(state.learningRateInputValue)\n                ? \"\"\n                : \"InvalidInput\"\n            }\n            value={state.learningRateInputValue}\n            onChange={this.onLearningRateInputValueChange}\n          />\n        </label>\n\n        <button\n          onClick={this.onStartTrainingClick}\n          disabled={\n            !(\n              isPositiveIntStr(state.batchSizeInputValue) &&\n              isPositiveIntStr(state.epochsInputValue) &&\n              isPositiveNumStr(state.learningRateInputValue)\n            )\n          }\n        >\n          Start\n        </button>\n      </div>\n    );\n  }\n\n  renderTrainingInProgressMenu(\n    state: TrainingInProgressState\n  ): React.ReactElement {\n    return (\n      <div className=\"App\">\n        <h1>Training in progress...</h1>\n\n        <h2>Logs:</h2>\n        {state.epochAccuracyRates\n          .slice()\n          .sort((a, b) => a.epoch - b.epoch)\n          .map((rate) => (\n            <div key={rate.epoch}>\n              Epoch {rate.epoch}: {rate.correct} / {rate.total}\n            </div>\n          ))}\n\n        <button onClick={this.onStopTrainingClick}>\n          Stop training after current epoch\n        </button>\n      </div>\n    );\n  }\n\n  renderTestMenu(state: TestState): React.ReactElement {\n    return (\n      <div className=\"App\">\n        <h1>Test results:</h1>\n\n        {state.accuracyRate.match({\n          err: () => <p>Running tests...</p>,\n          ok: (rate) => (\n            <p>\n              {rate.correct} / {rate.total} correct\n            </p>\n          ),\n        })}\n\n        <button onClick={this.onTestMenuExitClick}>Back</button>\n      </div>\n    );\n  }\n\n  renderViewMenu(state: ViewState): React.ReactElement {\n    return state.mnist.match({\n      none: () => (\n        <div className=\"App\">\n          <p>Loading...</p>\n        </div>\n      ),\n      some: (mnist) => {\n        const viewedImage: LabeledImage = getViewedImage(state, mnist);\n        const guess = guessDigit(state.network, viewedImage.inputs);\n\n        return (\n          <div className=\"App\">\n            <h1>View classifications</h1>\n            <button onClick={this.onExitViewMenuClick}>Back</button>\n\n            <div>\n              <button onClick={this.onPreviousImageClick}>Previous</button>{\" \"}\n              Image {state.viewedIndex + 1} /{\" \"}\n              {mnist.test.length + state.customImages.length}{\" \"}\n              <button onClick={this.onNextImageClick}>Next</button>\n            </div>\n\n            <canvas ref={this.viewImageCanvasRef}></canvas>\n\n            <div\n              className={\n                guess.digit === viewedImage.label ? \"\" : \"IncorrectGuess\"\n              }\n            >\n              Guess: {guess.digit} ({(guess.confidence * 100).toFixed(2)}%\n              confident)\n            </div>\n\n            <div>Actual: {viewedImage.label}</div>\n\n            {state.viewedIndex >= mnist.test.length && (\n              <div>\n                <button onClick={this.onDeleteCustomImageClick}>\n                  Delete this image\n                </button>\n              </div>\n            )}\n\n            <div>\n              <label>\n                Upload your own image:{\" \"}\n                <input\n                  type=\"file\"\n                  accept=\"image/*\"\n                  ref={this.customImageInputRef}\n                  onChange={this.onCustomImageInputChange}\n                />\n              </label>\n            </div>\n          </div>\n        );\n      },\n    });\n  }\n\n  renderCropMenu(state: CropState): React.ReactElement {\n    return (\n      <div\n        className=\"App\"\n        onMouseMove={this.onCropImageCanvasPointerMove}\n        onTouchMove={this.onCropImageCanvasPointerMove}\n        onMouseUp={this.onCropImageCanvasPointerUp}\n        onTouchEnd={this.onCropImageCanvasPointerUp}\n      >\n        <h1>Crop image</h1>\n\n        <div>\n          <canvas\n            ref={this.cropImageCanvasRef}\n            className={\n              \"CropImageCanvas WhiteBackground\" +\n              state.hoveredOverDraggable.match({\n                none: () => \"\",\n                some: (draggable): string => {\n                  switch (draggable) {\n                    case Draggable.TopLeftCorner:\n                    case Draggable.BottomRightCorner:\n                      return \" NwseResizeCursor\";\n                    case Draggable.TopRightCorner:\n                    case Draggable.BottomLeftCorner:\n                      return \" NeswResizeCursor\";\n                    case Draggable.EntireSquare:\n                      return \" MoveCursor\";\n                  }\n                },\n              })\n            }\n            onMouseDown={this.onCropImageCanvasPointerDown}\n            onTouchStart={this.onCropImageCanvasPointerDown}\n          ></canvas>\n        </div>\n\n        <div>\n          <label>\n            Invert{\" \"}\n            <input\n              type=\"checkbox\"\n              checked={state.shouldInvertImage}\n              onChange={this.onShouldInvertInputChange}\n            />\n          </label>\n        </div>\n\n        <div>\n          <label>\n            Darkness threshold:{\" \"}\n            <input\n              type=\"range\"\n              value={state.darknessThreshold}\n              min={0}\n              max={1}\n              step={0.001}\n              onChange={this.onDarknessThresholdChange}\n            />\n          </label>\n        </div>\n\n        <div>\n          <label>\n            Label:{\" \"}\n            <input\n              type=\"text\"\n              className={isDigit(state.labelInputValue) ? \"\" : \"InvalidInput\"}\n              value={state.labelInputValue}\n              onChange={this.onCustomImageLabelInputValueChange}\n            />\n          </label>\n        </div>\n\n        <button\n          disabled={!isDigit(state.labelInputValue)}\n          onClick={this.onAddCustomImageClick}\n        >\n          Add\n        </button>\n      </div>\n    );\n  }\n\n  componentDidUpdate(): void {\n    const { state } = this;\n    state.mnist.ifSome((mnist) => {\n      if (state.stateType === StateType.View) {\n        const canvas = this.viewImageCanvasRef.current;\n        if (canvas !== null) {\n          const viewedImage = getViewedImage(state, mnist);\n          paintImage(viewedImage, canvas);\n        }\n      } else if (state.stateType === StateType.Crop) {\n        const canvas = this.cropImageCanvasRef.current;\n        if (canvas !== null) {\n          const adjustedCropSquare = state.pendingCropAdjustment.match({\n            none: () => state.cropSquare,\n            some: (adjustment) => {\n              return applyPendingAdjustment(\n                state.cropSquare,\n                adjustment,\n                canvas.width,\n                canvas.height\n              );\n            },\n          });\n          paintImageAndCropSquare(\n            state.uploadedImage,\n            adjustedCropSquare,\n            canvas,\n            state.shouldInvertImage,\n            state.darknessThreshold\n          );\n        }\n      }\n    });\n  }\n\n  cancelNetworkReset(network: Network): void {\n    const newState: NetworkMainMenuState = {\n      mnist: this.state.mnist,\n\n      stateType: StateType.NetworkMainMenu,\n\n      network,\n    };\n    this.saveState(newState);\n  }\n\n  changeLayerSizeValue(\n    changedLayerIndex: number,\n    newValue: string,\n    state: CreateNetworkState\n  ): void {\n    this.saveState({\n      ...state,\n      hiddenLayerSizeInputValues: state.hiddenLayerSizeInputValues.map(\n        (value, hiddenLayerIndex) => {\n          const layerIndex = hiddenLayerIndex + 1;\n          if (layerIndex === changedLayerIndex) {\n            return newValue;\n          } else {\n            return value;\n          }\n        }\n      ),\n    });\n  }\n\n  addLayerBelow(layerIndex: number, state: CreateNetworkState): void {\n    this.saveState({\n      ...state,\n      hiddenLayerSizeInputValues: state.hiddenLayerSizeInputValues\n        .slice(0, layerIndex)\n        .concat([\"16\"], state.hiddenLayerSizeInputValues.slice(layerIndex)),\n    });\n  }\n\n  deleteLayer(layerIndex: number, state: CreateNetworkState): void {\n    const hiddenLayerIndex = layerIndex - 1;\n    this.saveState({\n      ...state,\n      hiddenLayerSizeInputValues: state.hiddenLayerSizeInputValues\n        .slice(0, hiddenLayerIndex)\n        .concat(state.hiddenLayerSizeInputValues.slice(hiddenLayerIndex + 1)),\n    });\n  }\n\n  onCreateNetworkClick(): void {\n    const state = this.expectState(StateType.CreateNetwork);\n    if (state.hiddenLayerSizeInputValues.every(isPositiveIntStr)) {\n      const hiddenLayerSizes: number[] = state.hiddenLayerSizeInputValues.map(\n        (str) => +str\n      );\n      const layerSizes = [784, ...hiddenLayerSizes, 10];\n\n      const newState: NetworkMainMenuState = {\n        mnist: this.state.mnist,\n\n        stateType: StateType.NetworkMainMenu,\n\n        network: new Network(layerSizes),\n      };\n\n      this.saveState(newState);\n    }\n  }\n\n  expectState<T extends StateType>(stateType: T): StateMap[T] {\n    const { state } = this;\n    if (state.stateType === stateType) {\n      return state as StateMap[T];\n    }\n    throw new Error(\n      \"Expecting a state of type \" +\n        StateType[stateType] +\n        \" but got state of type \" +\n        StateType[state.stateType]\n    );\n  }\n\n  onTrainClick(): void {\n    const state = this.expectState(StateType.NetworkMainMenu);\n    const newState: HyperParameterMenuState = {\n      mnist: state.mnist,\n\n      stateType: StateType.HyperParameterMenu,\n\n      network: state.network,\n\n      batchSizeInputValue: \"10\",\n      epochsInputValue: \"30\",\n      learningRateInputValue: \"3.0\",\n    };\n    this.saveState(newState);\n  }\n\n  onTestClick(): void {\n    const state = this.expectState(StateType.NetworkMainMenu);\n\n    const networkTester = testNetwork(state.network, {\n      onComplete: (accuracyRate) => {\n        this.updateState(StateType.Test, {\n          accuracyRate: result.ok(accuracyRate),\n        });\n      },\n    });\n\n    const newState: TestState = {\n      mnist: state.mnist,\n\n      stateType: StateType.Test,\n\n      network: state.network,\n\n      accuracyRate: result.err(networkTester),\n    };\n\n    this.saveState(newState);\n\n    networkTester.start();\n  }\n\n  updateState<T extends StateType>(\n    stateType: T,\n    updateOrUpdater:\n      | Partial<StateMap[T]>\n      | ((prevState: StateMap[T]) => Partial<StateMap[T]>)\n  ): void {\n    const { state } = this;\n    if (state.stateType === stateType) {\n      if (\"function\" === typeof updateOrUpdater) {\n        this.saveState({ ...state, ...updateOrUpdater(state as StateMap[T]) });\n      } else {\n        this.saveState({ ...state, ...updateOrUpdater });\n      }\n    }\n  }\n\n  onViewClick(): void {\n    const state = this.expectState(StateType.NetworkMainMenu);\n    const newState: ViewState = {\n      mnist: state.mnist,\n\n      stateType: StateType.View,\n\n      network: state.network,\n\n      viewedIndex: 0,\n      customImages: imageSaver.getState().unwrapOr([]),\n    };\n    this.saveState(newState);\n  }\n\n  onResetClick(): void {\n    const state = this.expectState(StateType.NetworkMainMenu);\n    const newState: CreateNetworkState = {\n      mnist: state.mnist,\n\n      stateType: StateType.CreateNetwork,\n\n      hiddenLayerSizeInputValues: [\"30\"],\n      previousNetwork: option.some(state.network),\n    };\n    this.saveState(newState);\n  }\n\n  onBatchSizeInputValueChange(\n    event: React.ChangeEvent<HTMLInputElement>\n  ): void {\n    const state = this.expectState(StateType.HyperParameterMenu);\n    const newState: HyperParameterMenuState = {\n      ...state,\n      batchSizeInputValue: event.target.value,\n    };\n    this.saveState(newState);\n  }\n\n  onEpochsInputValueChange(event: React.ChangeEvent<HTMLInputElement>): void {\n    const state = this.expectState(StateType.HyperParameterMenu);\n    const newState: HyperParameterMenuState = {\n      ...state,\n      epochsInputValue: event.target.value,\n    };\n    this.saveState(newState);\n  }\n\n  onLearningRateInputValueChange(\n    event: React.ChangeEvent<HTMLInputElement>\n  ): void {\n    const state = this.expectState(StateType.HyperParameterMenu);\n    const newState: HyperParameterMenuState = {\n      ...state,\n      learningRateInputValue: event.target.value,\n    };\n    this.saveState(newState);\n  }\n\n  onStartTrainingClick(): void {\n    const state = this.expectState(StateType.HyperParameterMenu);\n\n    const hyperParams: StochasticGradientDescentHyperParameters = {\n      batchSize: +state.batchSizeInputValue,\n      epochs: +state.epochsInputValue,\n      learningRate: +state.learningRateInputValue,\n    };\n\n    const networkTrainer = trainNetwork(state.network, hyperParams, {\n      onEpochComplete: this.onEpochComplete,\n\n      onTerminate: this.onTrainerTerminate,\n    });\n\n    const newState: TrainingInProgressState = {\n      mnist: state.mnist,\n\n      stateType: StateType.TrainingInProgress,\n\n      network: state.network,\n\n      networkTrainer,\n      epochAccuracyRates: [],\n    };\n\n    this.saveState(newState);\n\n    networkTrainer.start();\n  }\n\n  onEpochComplete(accuracyRate: AccuracyRate, epoch: number): void {\n    this.updateState(StateType.TrainingInProgress, (prevState) => ({\n      epochAccuracyRates: prevState.epochAccuracyRates.concat([\n        { ...accuracyRate, epoch },\n      ]),\n    }));\n  }\n\n  onTrainerTerminate(updatedNetwork: Network): void {\n    const state = this.expectState(StateType.TrainingInProgress);\n    const newState: NetworkMainMenuState = {\n      mnist: state.mnist,\n\n      stateType: StateType.NetworkMainMenu,\n\n      network: updatedNetwork,\n    };\n    this.saveState(newState);\n  }\n\n  onExitHyperParameterMenuClick(): void {\n    const state = this.expectState(StateType.HyperParameterMenu);\n    const newState: NetworkMainMenuState = {\n      mnist: state.mnist,\n\n      stateType: StateType.NetworkMainMenu,\n\n      network: state.network,\n    };\n    this.saveState(newState);\n  }\n\n  onStopTrainingClick(): void {\n    const state = this.expectState(StateType.TrainingInProgress);\n    state.networkTrainer.terminate();\n  }\n\n  onTestMenuExitClick(): void {\n    const state = this.expectState(StateType.Test);\n\n    state.accuracyRate.ifErr((tester) => {\n      tester.terminate();\n    });\n\n    const newState: NetworkMainMenuState = {\n      mnist: state.mnist,\n\n      stateType: StateType.NetworkMainMenu,\n\n      network: state.network,\n    };\n    this.saveState(newState);\n  }\n\n  onExitViewMenuClick(): void {\n    const state = this.expectState(StateType.View);\n\n    const newState: NetworkMainMenuState = {\n      mnist: state.mnist,\n\n      stateType: StateType.NetworkMainMenu,\n\n      network: state.network,\n    };\n    this.saveState(newState);\n  }\n\n  onPreviousImageClick(): void {\n    const state = this.expectState(StateType.View);\n    state.mnist.ifSome((mnist) => {\n      const numberOfImages = mnist.test.length + state.customImages.length;\n      const newIndex =\n        state.viewedIndex === 0 ? numberOfImages - 1 : state.viewedIndex - 1;\n      this.saveState({ ...state, viewedIndex: newIndex });\n    });\n  }\n\n  onNextImageClick(): void {\n    const state = this.expectState(StateType.View);\n    state.mnist.ifSome((mnist) => {\n      const numberOfImages = mnist.test.length + state.customImages.length;\n      const newIndex =\n        state.viewedIndex === numberOfImages - 1 ? 0 : state.viewedIndex + 1;\n      this.saveState({ ...state, viewedIndex: newIndex });\n    });\n  }\n\n  onCustomImageInputChange(): void {\n    const input = this.customImageInputRef.current;\n    if (input !== null && input.files !== null && input.files.length > 0) {\n      readFileAsHtmlImage(input.files[0]).then(this.enterCropMenu);\n    }\n  }\n\n  enterCropMenu(uploadedImage: HTMLImageElement): void {\n    const state = this.expectState(StateType.View);\n    const newState: CropState = {\n      mnist: state.mnist,\n\n      stateType: StateType.Crop,\n\n      network: state.network,\n      customImages: state.customImages,\n\n      uploadedImage,\n      darknessThreshold: getAverageDarkness(uploadedImage),\n      cropSquare: {\n        x: 0,\n        y: 0,\n        size: Math.min(uploadedImage.width, uploadedImage.height),\n      },\n      pendingCropAdjustment: option.none(),\n      hoveredOverDraggable: option.none(),\n      shouldInvertImage: false,\n      labelInputValue: \"\",\n    };\n    this.saveState(newState);\n  }\n\n  onCropImageCanvasPointerDown(\n    event:\n      | React.MouseEvent<HTMLCanvasElement>\n      | React.TouchEvent<HTMLCanvasElement>\n  ): void {\n    const state = this.expectState(StateType.Crop);\n    const square = state.cropSquare;\n\n    const canvas = this.cropImageCanvasRef.current!;\n    const { x, y } = getLocalPointerCoordinates(event, canvas);\n    const rect = canvas.getBoundingClientRect();\n    const scale = canvas.width / rect.width;\n    const localRadius = CropMenuConfig.GlobalCornerHandleRadius * scale;\n\n    const optDragged: Option<Draggable> = (() => {\n      if (Math.hypot(x - square.x, y - square.y) <= localRadius) {\n        return option.some(Draggable.TopLeftCorner);\n      } else if (\n        Math.hypot(x - (square.x + square.size), y - square.y) <= localRadius\n      ) {\n        return option.some(Draggable.TopRightCorner);\n      } else if (\n        Math.hypot(\n          x - (square.x + square.size),\n          y - (square.y + square.size)\n        ) <= localRadius\n      ) {\n        return option.some(Draggable.BottomRightCorner);\n      } else if (\n        Math.hypot(x - square.x, y - (square.y + square.size)) <= localRadius\n      ) {\n        return option.some(Draggable.BottomLeftCorner);\n      } else if (\n        x > square.x &&\n        x < square.x + square.size &&\n        y > square.y &&\n        y < square.y + square.size\n      ) {\n        return option.some(Draggable.EntireSquare);\n      } else {\n        return option.none();\n      }\n    })();\n\n    this.saveState({\n      ...state,\n      pendingCropAdjustment: optDragged.map((dragged) => ({\n        dragged,\n        startX: x,\n        startY: y,\n        currentX: x,\n        currentY: y,\n      })),\n    });\n  }\n\n  onCropImageCanvasPointerMove(\n    event: React.MouseEvent | React.TouchEvent\n  ): void {\n    const state = this.expectState(StateType.Crop);\n    const canvas = this.cropImageCanvasRef.current!;\n    const current = getLocalPointerCoordinates(event, canvas);\n\n    state.pendingCropAdjustment.match({\n      some: (oldAdjustment) => {\n        const updatedAdjustment: SquareAdjustment = {\n          ...oldAdjustment,\n          currentX: current.x,\n          currentY: current.y,\n        };\n\n        this.saveState({\n          ...state,\n          pendingCropAdjustment: option.some(updatedAdjustment),\n        });\n\n        const adjustedCropSquare = applyPendingAdjustment(\n          state.cropSquare,\n          updatedAdjustment,\n          canvas.width,\n          canvas.height\n        );\n        paintImageAndCropSquare(\n          state.uploadedImage,\n          adjustedCropSquare,\n          canvas,\n          state.shouldInvertImage,\n          state.darknessThreshold\n        );\n      },\n\n      none: () => {\n        const rect = canvas.getBoundingClientRect();\n        const scale = canvas.width / rect.width;\n        const localRadius = CropMenuConfig.GlobalCornerHandleRadius * scale;\n        this.saveState({\n          ...state,\n          hoveredOverDraggable: getHoveredOverDraggable(\n            state.cropSquare,\n            current.x,\n            current.y,\n            localRadius\n          ),\n        });\n      },\n    });\n  }\n\n  onCropImageCanvasPointerUp(): void {\n    const state = this.expectState(StateType.Crop);\n    const canvas = this.cropImageCanvasRef.current!;\n    const updatedCropSquare = state.pendingCropAdjustment.match({\n      none: () => state.cropSquare,\n      some: (adjustment) =>\n        applyPendingAdjustment(\n          state.cropSquare,\n          adjustment,\n          canvas.width,\n          canvas.height\n        ),\n    });\n\n    this.saveState({\n      ...state,\n      pendingCropAdjustment: option.none(),\n      cropSquare: updatedCropSquare,\n    });\n  }\n\n  onShouldInvertInputChange(event: React.ChangeEvent<HTMLInputElement>): void {\n    const state = this.expectState(StateType.Crop);\n    const newState: CropState = {\n      ...state,\n      shouldInvertImage: event.target.checked,\n    };\n    this.saveState(newState);\n  }\n\n  onDarknessThresholdChange(event: React.ChangeEvent<HTMLInputElement>): void {\n    const state = this.expectState(StateType.Crop);\n    const newThreshold = +event.target.value;\n    const newState: CropState = { ...state, darknessThreshold: newThreshold };\n    this.saveState(newState);\n    paintImageAndCropSquare(\n      state.uploadedImage,\n      state.cropSquare,\n      this.cropImageCanvasRef.current!,\n      state.shouldInvertImage,\n      newThreshold\n    );\n  }\n\n  onCustomImageLabelInputValueChange(\n    event: React.ChangeEvent<HTMLInputElement>\n  ): void {\n    const state = this.expectState(StateType.Crop);\n    const newState: CropState = {\n      ...state,\n      labelInputValue: event.target.value,\n    };\n    this.saveState(newState);\n  }\n\n  onAddCustomImageClick(): void {\n    const state = this.expectState(StateType.Crop);\n\n    if (!isDigit(state.labelInputValue)) {\n      return;\n    }\n\n    state.mnist.ifSome((mnist) => {\n      const label = +state.labelInputValue;\n      const newImage = getCustomImage(\n        state,\n        label,\n        state.shouldInvertImage,\n        state.darknessThreshold\n      );\n      const updatedCustomImages = state.customImages.concat([newImage]);\n      const newImageIndex = mnist.test.length + updatedCustomImages.length - 1;\n      const newState: ViewState = {\n        mnist: state.mnist,\n\n        stateType: StateType.View,\n\n        network: state.network,\n\n        viewedIndex: newImageIndex,\n        customImages: updatedCustomImages,\n      };\n      this.saveState(newState);\n    });\n  }\n\n  onDeleteCustomImageClick(): void {\n    const state = this.expectState(StateType.View);\n    state.mnist.ifSome((mnist) => {\n      const customImageIndex = state.viewedIndex - mnist.test.length;\n      const newCustomImages = state.customImages\n        .slice(0, customImageIndex)\n        .concat(state.customImages.slice(customImageIndex + 1));\n      const newState: ViewState = {\n        ...state,\n        customImages: newCustomImages,\n        viewedIndex: state.viewedIndex - 1,\n      };\n      this.saveState(newState);\n    });\n  }\n}\n\nfunction getInitialState(): AppState {\n  return networkSaver.getState().match({\n    none: (): CreateNetworkState => ({\n      mnist: option.none(),\n\n      stateType: StateType.CreateNetwork,\n\n      hiddenLayerSizeInputValues: [\"30\"],\n      previousNetwork: option.none(),\n    }),\n\n    some: (network): NetworkMainMenuState => ({\n      mnist: option.none(),\n\n      stateType: StateType.NetworkMainMenu,\n\n      network,\n    }),\n  });\n}\n\nfunction isPositiveIntStr(s: string): boolean {\n  return Number.isFinite(+s) && +s === Math.floor(+s) && +s > 0;\n}\n\nfunction isPositiveNumStr(s: string): boolean {\n  return Number.isFinite(+s) && +s > 0;\n}\n\nfunction getViewedImage(state: ViewState, mnist: MnistData): LabeledImage {\n  return state.viewedIndex < mnist.test.length\n    ? mnist.test[state.viewedIndex]\n    : normalizeU8Image(\n        state.customImages[state.viewedIndex - mnist.test.length]\n      );\n}\n\nfunction normalizeU8Image(image: CustomImage): LabeledImage {\n  return {\n    rows: 28,\n    columns: 28,\n    inputs: image.u8Matrix.immutApplyElementwise((x) => x / 255),\n    label: image.label,\n  };\n}\n\nfunction guessDigit(\n  network: Network,\n  inputs: Matrix\n): { digit: number; confidence: number } {\n  const { activations } = network.performForwardPass(inputs);\n  const outputActivations = activations[\n    activations.length - 1\n  ].rowMajorOrderEntries();\n\n  let maxIndex = 0;\n  let maxConfidence = outputActivations[maxIndex];\n  for (let i = 1; i < outputActivations.length; i++) {\n    const confidence = outputActivations[i];\n    if (confidence > maxConfidence) {\n      maxConfidence = confidence;\n      maxIndex = i;\n    }\n  }\n\n  return { digit: maxIndex, confidence: maxConfidence };\n}\n\nfunction paintImage(image: LabeledImage, canvas: HTMLCanvasElement): void {\n  canvas.width = image.columns;\n  canvas.height = image.rows;\n\n  const ctx = canvas.getContext(\"2d\")!;\n  const imageData = getImageData(image);\n  ctx.putImageData(imageData, 0, 0);\n}\n\nfunction getImageData(image: LabeledImage): ImageData {\n  const entries = image.inputs.rowMajorOrderEntries();\n  const imageBytes = new Uint8ClampedArray(entries.length * 4);\n  for (let i = 0; i < entries.length; i++) {\n    const lightness = 255 - Math.floor(entries[i] * 255);\n    imageBytes[i * 4] = lightness;\n    imageBytes[i * 4 + 1] = lightness;\n    imageBytes[i * 4 + 2] = lightness;\n    imageBytes[i * 4 + 3] = 255;\n  }\n  return new ImageData(imageBytes, image.columns, image.rows);\n}\n\nfunction readFileAsHtmlImage(file: File): Promise<HTMLImageElement> {\n  return readFileAsDataUrl(file).then(\n    (url) =>\n      new Promise((resolve, reject) => {\n        const img = document.createElement(\"img\");\n        img.src = url;\n        img.addEventListener(\"load\", () => resolve(img));\n        img.addEventListener(\"error\", reject);\n      })\n  );\n}\n\nfunction readFileAsDataUrl(file: File): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.addEventListener(\"load\", () => resolve(reader.result as string));\n    reader.addEventListener(\"error\", () => reject(reader.error));\n    reader.readAsDataURL(file);\n  });\n}\n\nconst CropMenuConfig = {\n  OverlayColor: \"#000a\",\n\n  CropSquareColor: \"#08b\",\n  CropSquareLineWidth: 3,\n  GlobalCornerHandleRadius: 10,\n} as const;\n\nfunction paintImageAndCropSquare(\n  image: HTMLImageElement,\n  crop: Square,\n  canvas: HTMLCanvasElement,\n  shouldInvert: boolean,\n  darknessThreshold: number\n): void {\n  canvas.width = image.width;\n  canvas.height = image.height;\n\n  const rect = canvas.getBoundingClientRect();\n  const scale = canvas.width / rect.width;\n\n  const ctx = canvas.getContext(\"2d\")!;\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.drawImage(image, 0, 0);\n\n  if (shouldInvert) {\n    invertContext(ctx);\n  }\n\n  paintOverlay();\n  paintCompressedImage();\n  paintCropSquare();\n\n  return;\n\n  function paintOverlay(): void {\n    const cropBottom = crop.y + crop.size;\n    const cropRight = crop.x + crop.size;\n    ctx.fillStyle = CropMenuConfig.OverlayColor;\n    ctx.fillRect(0, 0, canvas.width, crop.y);\n    ctx.fillRect(0, cropBottom, canvas.width, canvas.height - cropBottom);\n    ctx.fillRect(0, crop.y, crop.x, crop.size);\n    ctx.fillRect(cropRight, crop.y, canvas.width - cropRight, crop.size);\n  }\n\n  function paintCompressedImage(): void {\n    ctx.clearRect(crop.x, crop.y, crop.size, crop.size);\n\n    const compressed = cropAndCompress(\n      image,\n      crop,\n      shouldInvert,\n      darknessThreshold\n    );\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(compressed, crop.x, crop.y, crop.size, crop.size);\n  }\n\n  function paintCropSquare(): void {\n    ctx.strokeStyle = CropMenuConfig.CropSquareColor;\n    ctx.lineWidth = CropMenuConfig.CropSquareLineWidth;\n    ctx.strokeRect(crop.x, crop.y, crop.size, crop.size);\n\n    drawCropSquareCircle(crop.x, crop.y);\n    drawCropSquareCircle(crop.x + crop.size, crop.y);\n    drawCropSquareCircle(crop.x + crop.size, crop.y + crop.size);\n    drawCropSquareCircle(crop.x, crop.y + crop.size);\n  }\n\n  function drawCropSquareCircle(x: number, y: number): void {\n    const localRadius = CropMenuConfig.GlobalCornerHandleRadius * scale;\n    ctx.moveTo(x, y);\n    ctx.beginPath();\n    ctx.arc(x, y, localRadius, 0, 2 * Math.PI);\n    ctx.closePath();\n\n    ctx.fillStyle = CropMenuConfig.CropSquareColor;\n    ctx.fill();\n  }\n}\n\nfunction applyWhiteBackground(srcCtx: CanvasRenderingContext2D): void {\n  const { width, height } = srcCtx.canvas;\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n\n  const ctx = canvas.getContext(\"2d\")!;\n  ctx.fillStyle = \"#ffffff\";\n  ctx.fillRect(0, 0, width, height);\n  ctx.drawImage(srcCtx.canvas, 0, 0);\n\n  const imageData = ctx.getImageData(0, 0, width, height);\n  srcCtx.putImageData(imageData, 0, 0);\n}\n\nfunction getLocalPointerCoordinates(\n  event: React.MouseEvent | React.TouchEvent,\n  canvas: HTMLCanvasElement\n): { x: number; y: number } {\n  const boundingRect = canvas.getBoundingClientRect();\n  const { x, y } = getGlobalPointerCoordinates(event);\n  const xScale = canvas.width / boundingRect.width;\n  const yScale = canvas.height / boundingRect.height;\n  return {\n    x: xScale * (x - boundingRect.left),\n    y: yScale * (y - boundingRect.top),\n  };\n}\n\nfunction getGlobalPointerCoordinates(\n  event: React.MouseEvent | React.TouchEvent\n): { x: number; y: number } {\n  if (\"clientX\" in event) {\n    return { x: event.clientX, y: event.clientY };\n  } else {\n    return { x: event.touches[0].clientX, y: event.touches[0].clientY };\n  }\n}\n\nfunction applyPendingAdjustment(\n  square: Square,\n  adjustment: SquareAdjustment,\n  canvasWidth: number,\n  canvasHeight: number\n): Square {\n  const possiblyOutOfBounds = applyPendingAdjustmentToGetPossiblyOutOfBoundsSquare(\n    square,\n    adjustment\n  );\n  return transformBackIntoBoundsIfNeeded(\n    possiblyOutOfBounds,\n    canvasWidth,\n    canvasHeight,\n    adjustment.dragged === Draggable.EntireSquare\n  );\n}\n\nfunction applyPendingAdjustmentToGetPossiblyOutOfBoundsSquare(\n  square: Square,\n  adjustment: SquareAdjustment\n): Square {\n  if (isCornerAdjustment(adjustment)) {\n    const rect = {\n      x: square.x,\n      y: square.y,\n      width: square.size,\n      height: square.size,\n    };\n    const adjustedRect = applyPendingCornerAdjustmentToRect(rect, adjustment);\n    return clamp(adjustedRect, adjustment.dragged);\n  } else {\n    const dx = adjustment.currentX - adjustment.startX;\n    const dy = adjustment.currentY - adjustment.startY;\n    return applyTranslation(square, dx, dy);\n  }\n}\n\nfunction isCornerAdjustment(\n  adjustment: SquareAdjustment\n): adjustment is CornerAdjustment {\n  return adjustment.dragged !== Draggable.EntireSquare;\n}\n\nfunction applyPendingCornerAdjustmentToRect(\n  rect: Rect,\n  adjustment: CornerAdjustment\n): Rect {\n  const corner = adjustment.dragged;\n  const { currentX, currentY } = adjustment;\n\n  let left = rect.x;\n  let right = rect.x + rect.width;\n  let top = rect.y;\n  let bottom = rect.y + rect.height;\n\n  switch (corner) {\n    case Draggable.TopLeftCorner:\n      top = Math.min(currentY, bottom);\n      left = Math.min(currentX, right);\n      break;\n    case Draggable.TopRightCorner:\n      top = Math.min(currentY, bottom);\n      right = Math.max(currentX, left);\n      break;\n    case Draggable.BottomRightCorner:\n      bottom = Math.max(currentY, top);\n      right = Math.max(currentX, left);\n      break;\n    case Draggable.BottomLeftCorner:\n      bottom = Math.max(currentY, top);\n      left = Math.min(currentX, right);\n      break;\n  }\n\n  if (left > right) {\n    [left, right] = [right, left];\n  }\n  if (top > bottom) {\n    [top, bottom] = [bottom, top];\n  }\n\n  return {\n    x: left,\n    y: top,\n    width: right - left,\n    height: bottom - top,\n  };\n}\n\nfunction clamp(rect: Rect, dragged: Corner): Square {\n  const anchor = getDiagonal(dragged);\n  switch (anchor) {\n    case Draggable.TopLeftCorner:\n      return clampToTopLeft(rect);\n    case Draggable.TopRightCorner:\n      return clampToTopRight(rect);\n    case Draggable.BottomRightCorner:\n      return clampToBottomRight(rect);\n    case Draggable.BottomLeftCorner:\n      return clampToBottomLeft(rect);\n  }\n}\n\nfunction clampToTopLeft(rect: Rect): Square {\n  const { x, y, width, height } = rect;\n  const size = Math.min(width, height);\n  return { x, y, size };\n}\n\nfunction clampToTopRight(rect: Rect): Square {\n  const { x, y, width, height } = rect;\n  const size = Math.min(width, height);\n  return { x: width > height ? x + width - size : x, y, size };\n}\n\nfunction clampToBottomRight(rect: Rect): Square {\n  const { x, y, width, height } = rect;\n  const size = Math.min(width, height);\n  return {\n    x: width > height ? x + width - size : x,\n    y: height > width ? y + height - size : y,\n    size,\n  };\n}\n\nfunction clampToBottomLeft(rect: Rect): Square {\n  const { x, y, width, height } = rect;\n  const size = Math.min(width, height);\n  return { x, y: height > width ? y + height - size : y, size };\n}\n\nfunction getDiagonal(corner: Corner): Corner {\n  switch (corner) {\n    case Draggable.TopLeftCorner:\n      return Draggable.BottomRightCorner;\n    case Draggable.TopRightCorner:\n      return Draggable.BottomLeftCorner;\n    case Draggable.BottomRightCorner:\n      return Draggable.TopLeftCorner;\n    case Draggable.BottomLeftCorner:\n      return Draggable.TopRightCorner;\n  }\n}\n\nfunction applyTranslation(square: Square, dx: number, dy: number): Square {\n  return { x: square.x + dx, y: square.y + dy, size: square.size };\n}\n\nfunction getHoveredOverDraggable(\n  square: Square,\n  x: number,\n  y: number,\n  localRadius: number\n): Option<Draggable> {\n  if (Math.hypot(x - square.x, y - square.y) <= localRadius) {\n    return option.some(Draggable.TopLeftCorner);\n  } else if (\n    Math.hypot(x - (square.x + square.size), y - square.y) <= localRadius\n  ) {\n    return option.some(Draggable.TopRightCorner);\n  } else if (\n    Math.hypot(x - (square.x + square.size), y - (square.y + square.size)) <=\n    localRadius\n  ) {\n    return option.some(Draggable.BottomRightCorner);\n  } else if (\n    Math.hypot(x - square.x, y - (square.y + square.size)) <= localRadius\n  ) {\n    return option.some(Draggable.BottomLeftCorner);\n  } else if (\n    x > square.x &&\n    x < square.x + square.size &&\n    y > square.y &&\n    y < square.y + square.size\n  ) {\n    return option.some(Draggable.EntireSquare);\n  } else {\n    return option.none();\n  }\n}\n\nfunction transformBackIntoBoundsIfNeeded(\n  square: Square,\n  width: number,\n  height: number,\n  preserveSize: boolean\n): Square {\n  if (preserveSize) {\n    const { x, y, size } = square;\n\n    const maxX = width - size;\n    const maxY = height - size;\n\n    return {\n      x: Math.max(0, Math.min(x, maxX)),\n      y: Math.max(0, Math.min(y, maxY)),\n      size,\n    };\n  } else {\n    let { x, y, size } = square;\n\n    x = Math.max(0, Math.min(x, width));\n    y = Math.max(0, Math.min(y, height));\n\n    const maxSize = Math.min(width - x, height - y);\n    size = Math.min(size, maxSize);\n\n    return { x, y, size };\n  }\n}\n\nfunction cropAndCompress(\n  image: HTMLImageElement,\n  crop: Square,\n  shouldInvert: boolean,\n  darknessThreshold: number\n): HTMLCanvasElement {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 28;\n  canvas.height = 28;\n\n  const ctx = canvas.getContext(\"2d\")!;\n  ctx.drawImage(image, crop.x, crop.y, crop.size, crop.size, 0, 0, 28, 28);\n\n  applyGrayscale(ctx);\n\n  if (shouldInvert) {\n    invertContext(ctx);\n  }\n\n  applyDarknessThreshold(ctx, darknessThreshold);\n\n  return canvas;\n}\n\nfunction invertContext(ctx: CanvasRenderingContext2D): void {\n  const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);\n  const bytes = imageData.data;\n  for (let i = 0; i < bytes.length; i += 4) {\n    bytes[i] = 255 - bytes[i];\n    bytes[i + 1] = 255 - bytes[i + 1];\n    bytes[i + 2] = 255 - bytes[i + 2];\n  }\n  ctx.putImageData(imageData, 0, 0);\n}\n\nfunction applyGrayscale(ctx: CanvasRenderingContext2D): void {\n  const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);\n  const pixels = imageData.data;\n  for (let i = 0; i < pixels.length; i += 4) {\n    const averageLightness = Math.floor(\n      (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3\n    );\n    pixels[i] = averageLightness;\n    pixels[i + 1] = averageLightness;\n    pixels[i + 2] = averageLightness;\n  }\n  ctx.putImageData(imageData, 0, 0);\n}\n\nfunction applyDarknessThreshold(\n  ctx: CanvasRenderingContext2D,\n  darknessThreshold: number\n): void {\n  const lightnessThreshold = 1 - darknessThreshold;\n  const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);\n  const pixels = imageData.data;\n  for (let i = 0; i < pixels.length; i += 4) {\n    const averageLightness = Math.floor(\n      (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3\n    );\n    const normalizedLightness = averageLightness / 255;\n    const roundedLightness = normalizedLightness < lightnessThreshold ? 0 : 255;\n    pixels[i] = roundedLightness;\n    pixels[i + 1] = roundedLightness;\n    pixels[i + 2] = roundedLightness;\n  }\n  ctx.putImageData(imageData, 0, 0);\n}\n\nfunction isDigit(s: string): boolean {\n  return /^\\d$/.test(s);\n}\n\nfunction getCustomImage(\n  state: CropState,\n  label: number,\n  shouldInvert: boolean,\n  darknessThreshold: number\n): CustomImage {\n  const { cropSquare, uploadedImage } = state;\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 28;\n  canvas.height = 28;\n\n  const ctx = canvas.getContext(\"2d\")!;\n\n  ctx.imageSmoothingEnabled = false;\n  ctx.drawImage(\n    uploadedImage,\n    cropSquare.x,\n    cropSquare.y,\n    cropSquare.size,\n    cropSquare.size,\n    0,\n    0,\n    28,\n    28\n  );\n\n  if (shouldInvert) {\n    invertContext(ctx);\n  }\n\n  applyWhiteBackground(ctx);\n\n  const u8Matrix = getU8Matrix(\n    ctx.getImageData(0, 0, 28, 28),\n    darknessThreshold\n  );\n  return { u8Matrix, label };\n}\n\nfunction getU8Matrix(imageData: ImageData, darknessThreshold: number): Matrix {\n  const lightnessThreshold = 1 - darknessThreshold;\n\n  const { data } = imageData;\n  const u8s = new Array(data.length / 4);\n  for (let i = 0; i < data.length; i += 4) {\n    const averageLightness = Math.floor(\n      (data[i] + data[i + 1] + data[i + 2]) / 3\n    );\n    const normalizedLightness = averageLightness / 255;\n    const roundedLightness = normalizedLightness < lightnessThreshold ? 0 : 255;\n    const roundedDarkness = 255 - roundedLightness;\n    u8s[i / 4] = roundedDarkness;\n  }\n  return Matrix.columnVector(u8s);\n}\n\n/** Returns a float between 0 and 1. */\nfunction getAverageDarkness(image: HTMLImageElement): number {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = image.width;\n  canvas.height = image.height;\n\n  const ctx = canvas.getContext(\"2d\")!;\n\n  ctx.fillStyle = \"#ffffff\";\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n  ctx.drawImage(image, 0, 0);\n\n  const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n  let totalLightness = 0;\n  for (let i = 0; i < pixels.length; i += 4) {\n    const lightness = Math.floor(\n      (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3\n    );\n    totalLightness += lightness;\n  }\n  const numberOfPixels = pixels.length / 4;\n  const averageLightness = Math.floor(totalLightness / numberOfPixels);\n  const averageDarkness = 255 - averageLightness;\n  return averageDarkness / 255;\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { Network } from \"./network\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\n(window as any).Network = Network;\n"],"sourceRoot":""}