{"version":3,"sources":["workers/networkTester.ts","workers/networkTrainer.ts","matrix.ts","data/index.ts","data/mnist.ts","network/index.ts","random.ts","network/utils.ts","network/networks/ch3crossEntropyL2Momentum.ts","network/networkFactory.ts","workerMessages.ts","networkSerializer.ts","state.ts","stateSavers.ts","workers/networkTester.importable.js","workers/networkTrainer.importable.js","networkServices.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","Worker","Matrix","rows","columns","data","this","Float64Array","from","size","i","Math","random","initializer","map","length","some","row","Error","JSON","stringify","flat","entries","slice","n","out","thisData","outData","outSize","other","TypeError","subtractInto","clone","otherData","multiplyInto","zeros","thisRows","otherColumns","thisColumns","outColumns","thisR","otherC","dot","thisC","transposeInto","r","c","f","applyElementwiseInto","name","thisSize","decimals","entryStrings","Array","rowMajorOrderEntries","entry","toFixed","entryStringLengths","s","maxLength","max","topAndBottomBorder","repeat","str","leftpad","minLength","fillCharacter","diff","Idx3FileFormat","offset","requiredValue","Idx1FileFormat","getLabeledImages","imagesBuffer","labelsBuffer","images","buffer","bytes","Uint8Array","actual","getInt32MsbFirst","expected","toString","assertIdx3MagicNumberIsCorrect","numberOfImages","imagesParsed","firstPixelIndex","vectorEntries","j","matrix","columnVector","getImages","labels","assertIdx1MagicNumberIsCorrect","numberOfLabels","firstLabelIndex","getLabels","labeledImages","inputs","label","convertLabelToVector","image","fill","outputs","location","self","TRAINING_IMAGES_URL","url","resolve","href","TRAINING_LABELS_URL","TEST_IMAGES_URL","TEST_LABELS_URL","trainingImagesProm","getArrayBuffer","trainingLabelsProm","testImagesProm","testLabelsProm","fetch","then","response","status","arrayBuffer","statusText","text","getErrorMessage","errorMessage","Promise","reject","WeightInitializationMethod","mnistProm","all","trainingImagesBuffer","trainingLabelsBuffer","testImagesBuffer","testLabelsBuffer","training","test","uniformRandom","normalRandom","mean","variance","u1","u2","z1","sqrt","log","cos","PI","divideIntoMiniBatches","trainingData","miniBatchSize","arr","exclMax","floor","temp","shuffle","miniBatches","push","argmax","maxIndex","value","Chapter3CrossEntropyL2NetworkMomentum","weights","biases","numberOfLayers","weightVelocities","biasVelocities","temp_totalWeightGradients","temp_totalBiasGradients","temp_weightedSums","temp_activations","temp_errors","temp_weightGradients","temp_biasGradients","temp_transposedActivations","temp_weightCosts","temp_transposedWeights","temp_sigmaPrimeOfWeightedSums","layerSizes","getZeroMatrixMap","weightedSums","activations","outputLayer","transposedActivations","transposedWeights","initializationMethod","inputLayer","outputLayerSize","inputLayerSize","method","Uniform","LargeGaussian","SmallGaussian","initializeWeights","hyperParams","testData","batchSize","epochs","learningRate","momentumCoefficient","trainingDataSize","epoch","miniBatch","getTotalGradients","regularizationRate","weightGradients","biasGradients","mutMultiplyScalar","mutSubtract","mutAdd","undefined","accuracyRate","resetTotalGradientTemps","totalWeightGradients","totalBiasGradients","getGradients","setToZero","performForwardPass","errors","lastLayerError","multiplyScalarInto","copyInto","error","mutHadamard","sigmaPrime","sigma","correctClassifications","correct","total","z","exp","sigmaZ","zeroMatrices","WorkerMessageType","networkFactory","fromLayerSizes","fromWeightsAndBiases","serializeNetwork","network","getWeights","getBiases","entryCount","weightMatrix","weightMatrixSize","biasMatrix","biasMatrixSize","cursor","weightMatrixEntries","set","biasMatrixEntries","getEntries","numberOfBytesForSizes","Uint32Array","BYTES_PER_ELEMENT","ArrayBuffer","uints","src","dest","byteOffset","srcU8s","destU8s","putBuffer","deserializeNetwork","fromRowMajorOrderEntries","toArray","subarray","floats","StateType","Draggable","LocalStorageKeys","NetworkTesterWorker","NetworkTrainerWorker","trainNetwork","listeners","worker","addEventListener","event","message","messageType","TrainingEpochCompleteNotification","onEpochComplete","notifyListenersOfEpochCompletion","TerminateTrainingResponse","updatedNetwork","networkBuffer","onTerminate","terminate","notifyListenersOfTermination","start","StartTrainingRequest","postMessage","TerminateTrainingRequest","testNetwork","onComplete","notifyListenersOfTestingCompletion","StartTestingRequest","imageSaver","stateStr","localStorage","getItem","CustomImages","option","none","decodeBytes","byteVectors","imageBytes","u8Matrix","encodeBytes","setItem","networkSaver","NeuralNetwork","numberOfBytes","toU32","charCodeAt","code","byte","u8s","u16s","ceil","String","fromCharCode","stringifyU16s","App","props","viewImageCanvasRef","customImageInputRef","cropImageCanvasRef","state","match","mnist","stateType","CreateNetwork","hiddenLayerSizeInputValues","weightInitializationMethod","previousNetwork","NetworkMainMenu","React","createRef","bindMethods","window","app","onWeightInitializationMethodChange","bind","onCreateNetworkClick","onTrainClick","onTestClick","onViewClick","onResetClick","onBatchSizeInputValueChange","onEpochsInputValueChange","onLearningRateInputValueChange","onRegularizationRateInputValueChange","onMomentumCoefficientInputValueChange","onStartTrainingClick","onTrainerTerminate","onExitHyperParameterMenuClick","onStopTrainingClick","onTestMenuExitClick","onExitViewMenuClick","onPreviousImageClick","onNextImageClick","onCustomImageInputChange","enterCropMenu","onCropImageCanvasPointerDown","onCropImageCanvasPointerMove","onCropImageCanvasPointerUp","onShouldInvertInputChange","onDarknessThresholdChange","onCustomImageLabelInputValueChange","onDeleteCustomImageClick","onAddCustomImageClick","setState","newState","MnistLoadingError","saveState","customImages","renderCreateNetworkMenu","renderNetworkMainMenu","HyperParameterMenu","renderHyperParameterMenu","TrainingInProgress","renderTrainingInProgressMenu","Test","renderTestMenu","View","renderViewMenu","Crop","renderCropMenu","renderMnistLoadingErrorScreen","className","onClick","cancelNetworkReset","addLayerBelow","hiddenLayerIndex","layerIndex","key","type","isPositiveIntStr","onChange","e","changeLayerSizeValue","target","deleteLayer","disabled","join","batchSizeInputValue","epochsInputValue","isPositiveNumStr","learningRateInputValue","regularizationRateInputValue","isOnInclusiveUnitInterval","momentumCoefficientInputValue","min","step","Number","isNaN","epochAccuracyRates","sort","a","b","rate","err","ok","viewedImage","getViewedImage","guess","outputActivations","maxConfidence","confidence","digit","guessDigit","viewedIndex","ref","accept","onMouseMove","onTouchMove","onMouseUp","onTouchEnd","hoveredOverDraggable","draggable","TopLeftCorner","BottomRightCorner","TopRightCorner","BottomLeftCorner","EntireSquare","onMouseDown","onTouchStart","checked","shouldInvertImage","darknessThreshold","isDigit","labelInputValue","ifSome","canvas","current","width","height","ctx","getContext","imageData","Uint8ClampedArray","lightness","ImageData","getImageData","putImageData","paintImage","adjustedCropSquare","pendingCropAdjustment","cropSquare","adjustment","applyPendingAdjustment","paintImageAndCropSquare","uploadedImage","changedLayerIndex","newValue","concat","expectState","every","hiddenLayerSizes","networkTester","updateState","result","updateOrUpdater","unwrapOr","networkTrainer","prevState","ifErr","tester","newIndex","file","input","files","reader","FileReader","readAsDataURL","readFileAsDataUrl","img","document","createElement","getAverageDarkness","x","y","square","getLocalPointerCoordinates","rect","getBoundingClientRect","scale","localRadius","CropMenuConfig","GlobalCornerHandleRadius","optDragged","hypot","dragged","startX","startY","currentX","currentY","oldAdjustment","updatedAdjustment","getHoveredOverDraggable","updatedCropSquare","newThreshold","newImage","shouldInvert","imageSmoothingEnabled","drawImage","invertContext","srcCtx","fillStyle","fillRect","applyWhiteBackground","getU8Matrix","getCustomImage","updatedCustomImages","newImageIndex","customImageIndex","newCustomImages","Component","isFinite","immutApplyElementwise","OverlayColor","CropSquareColor","CropSquareLineWidth","crop","clearRect","cropBottom","cropRight","paintOverlay","compressed","pixels","averageLightness","applyGrayscale","lightnessThreshold","roundedLightness","applyDarknessThreshold","cropAndCompress","paintCompressedImage","strokeStyle","lineWidth","strokeRect","drawCropSquareCircle","moveTo","beginPath","arc","closePath","boundingRect","clientX","clientY","touches","getGlobalPointerCoordinates","xScale","yScale","left","top","canvasWidth","canvasHeight","preserveSize","maxX","maxY","maxSize","transformBackIntoBoundsIfNeeded","isCornerAdjustment","corner","getDiagonal","clampToTopLeft","clampToTopRight","clampToBottomRight","clampToBottomLeft","clamp","right","bottom","applyPendingCornerAdjustmentToRect","dx","dy","applyTranslation","applyPendingAdjustmentToGetPossiblyOutOfBoundsSquare","roundedDarkness","totalLightness","numberOfPixels","Boolean","hostname","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","console"],"mappings":"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","file":"static/js/main.ec80cb4c.chunk.js","sourcesContent":["module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"9f33208249dc31c5c687.worker.js\");\n};","module.exports = function() {\n  return new Worker(__webpack_public_path__ + \"6f63fe1657b9133450d1.worker.js\");\n};","export class Matrix {\n  /** @deprecated Use `Matrix.fromEntryInitializer(rows, columns, uniformRng)` instead. */\n  static randomUniform(rows: number, columns: number): Matrix {\n    const size = rows * columns;\n    const data = new Float64Array(size);\n    for (let i = 0; i < size; i++) {\n      data[i] = Math.random() * 2 - 1;\n    }\n    return new Matrix(rows, columns, data);\n  }\n\n  static fromEntryInitializer(\n    rows: number,\n    columns: number,\n    initializer: () => number\n  ) {\n    const data = new Float64Array(rows * columns).map(initializer);\n    return new Matrix(rows, columns, data);\n  }\n\n  static zeros(rows: number, columns: number): Matrix {\n    const data = new Float64Array(rows * columns);\n    return new Matrix(rows, columns, data);\n  }\n\n  static fromRows(rows: number[][]): Matrix {\n    const columns = rows[0].length;\n    if (rows.some((row) => row.length !== columns)) {\n      throw new Error(\n        \"Cannot create a matrix from a jagged array: \" + JSON.stringify(rows)\n      );\n    }\n\n    return new Matrix(rows.length, columns, rows.flat());\n  }\n\n  static columnVector(entries: number[]): Matrix {\n    return new Matrix(entries.length, 1, entries);\n  }\n\n  static fromRowMajorOrderEntries(\n    rows: number,\n    columns: number,\n    entries: ArrayLike<number>\n  ): Matrix {\n    if (entries.length !== rows * columns) {\n      throw new Error(\n        \"Expected \" +\n          rows * columns +\n          \" entries but instead got \" +\n          entries.length +\n          \".\"\n      );\n    }\n\n    return new Matrix(rows, columns, entries);\n  }\n\n  public readonly rows: number;\n  public readonly columns: number;\n  private data: Float64Array;\n\n  private constructor(rows: number, columns: number, data: ArrayLike<number>) {\n    this.rows = rows;\n    this.columns = columns;\n    this.data = data instanceof Float64Array ? data : Float64Array.from(data);\n  }\n\n  clone(): Matrix {\n    return new Matrix(this.rows, this.columns, this.data.slice());\n  }\n\n  mutMultiplyScalar(n: number): this {\n    const size = this.data.length;\n    for (let i = 0; i < size; i++) {\n      this.data[i] *= n;\n    }\n    return this;\n  }\n\n  multiplyScalarInto(n: number, out: Matrix): Matrix {\n    if (!(this.rows === out.rows && this.columns === out.columns)) {\n      throw new Error(\n        \"Cannot multiply a scalar \" +\n          n +\n          \" by a \" +\n          this.rows +\n          \"x\" +\n          this.columns +\n          \" matrix into a \" +\n          out.rows +\n          \"x\" +\n          out.columns +\n          \" matrix. The out matrix must have the same dimensions as this matrix.\"\n      );\n    }\n\n    const thisData = this.data;\n    const outData = out.data;\n    const outSize = outData.length;\n    for (let i = 0; i < outSize; i++) {\n      outData[i] = n * thisData[i];\n    }\n    return out;\n  }\n\n  mutAdd(other: Matrix): this {\n    if (!(other.rows === this.rows && other.columns === this.columns)) {\n      throw new TypeError(\n        \"Cannot add a \" +\n          this.rows +\n          \"x\" +\n          this.columns +\n          \" to a \" +\n          other.rows +\n          \"x\" +\n          other.columns +\n          \" matrix.\"\n      );\n    }\n\n    const size = this.data.length;\n    for (let i = 0; i < size; i++) {\n      this.data[i] += other.data[i];\n    }\n\n    return this;\n  }\n\n  mutSubtract(other: Matrix): this {\n    if (!(other.rows === this.rows && other.columns === this.columns)) {\n      throw new TypeError(\n        \"Cannot add a \" +\n          this.rows +\n          \"x\" +\n          this.columns +\n          \" to a \" +\n          other.rows +\n          \"x\" +\n          other.columns +\n          \" matrix.\"\n      );\n    }\n\n    const size = this.data.length;\n    for (let i = 0; i < size; i++) {\n      this.data[i] -= other.data[i];\n    }\n\n    return this;\n  }\n\n  immutSubtract(other: Matrix): Matrix {\n    return this.subtractInto(other, this.clone());\n  }\n\n  subtractInto(other: Matrix, out: Matrix): Matrix {\n    if (!(other.rows === this.rows && other.columns === this.columns)) {\n      throw new TypeError(\n        \"Cannot add a \" +\n          this.rows +\n          \"x\" +\n          this.columns +\n          \" matrix to a \" +\n          other.rows +\n          \"x\" +\n          other.columns +\n          \" matrix.\"\n      );\n    }\n\n    const thisData = this.data;\n    const otherData = other.data;\n    const outData = out.data;\n    const outSize = outData.length;\n    for (let i = 0; i < outSize; i++) {\n      outData[i] = thisData[i] - otherData[i];\n    }\n    return out;\n  }\n\n  immutMultiply(other: Matrix): Matrix {\n    return this.multiplyInto(other, Matrix.zeros(this.rows, other.columns));\n  }\n\n  multiplyInto(other: Matrix, out: Matrix): Matrix {\n    if (this.columns !== other.rows) {\n      throw new TypeError(\n        \"Cannot multiply a \" +\n          this.rows +\n          \"x\" +\n          this.columns +\n          \" matrix with a \" +\n          other.rows +\n          \"x\" +\n          other.columns +\n          \" matrix.\"\n      );\n    }\n\n    if (!(this.rows === out.rows && other.columns === out.columns)) {\n      throw new TypeError(\n        \"Cannot multiply a \" +\n          this.rows +\n          \"x\" +\n          this.columns +\n          \" matrix with a \" +\n          other.rows +\n          \"x\" +\n          other.columns +\n          \" matrix into a \" +\n          out.rows +\n          \"x\" +\n          out.columns +\n          \" matrix.\"\n      );\n    }\n\n    const thisData = this.data;\n    const otherData = other.data;\n    const outData = out.data;\n    const thisRows = this.rows;\n    const otherColumns = other.columns;\n    const thisColumns = this.columns;\n    const outColumns = out.columns;\n\n    for (let thisR = 0; thisR < thisRows; thisR++) {\n      for (let otherC = 0; otherC < otherColumns; otherC++) {\n        let dot = 0;\n        for (let thisC = 0; thisC < thisColumns; thisC++) {\n          dot +=\n            thisData[thisR * thisColumns + thisC] *\n            otherData[thisC * otherColumns + otherC];\n        }\n        outData[thisR * outColumns + otherC] = dot;\n      }\n    }\n    return out;\n  }\n\n  mutHadamard(other: Matrix): this {\n    if (!(other.rows === this.rows && other.columns === this.columns)) {\n      throw new TypeError(\n        \"Cannot take the Hadamard product of a \" +\n          this.rows +\n          \"x\" +\n          this.columns +\n          \" matrix and a \" +\n          other.rows +\n          \"x\" +\n          other.columns +\n          \" matrix.\"\n      );\n    }\n\n    const size = this.data.length;\n    for (let i = 0; i < size; i++) {\n      this.data[i] *= other.data[i];\n    }\n    return this;\n  }\n\n  immutTranspose(): Matrix {\n    return this.transposeInto(\n      new Matrix(this.columns, this.rows, new Float64Array(this.data.length))\n    );\n  }\n\n  transposeInto(out: Matrix): Matrix {\n    if (!(this.rows === out.columns && this.columns === out.rows)) {\n      throw new Error(\n        \"Cannot transpose a \" +\n          this.rows +\n          \"x\" +\n          this.columns +\n          \" matrix into a \" +\n          out.rows +\n          \"x\" +\n          out.columns +\n          \" matrix.\"\n      );\n    }\n\n    const thisData = this.data;\n    const thisRows = this.rows;\n    const thisColumns = this.columns;\n    const outData = out.data;\n    const outColumns = out.columns;\n\n    for (let r = 0; r < thisRows; r++) {\n      for (let c = 0; c < thisColumns; c++) {\n        outData[c * outColumns + r] = thisData[r * thisColumns + c];\n      }\n    }\n    return out;\n  }\n\n  rowMajorOrderEntries(): ArrayLike<number> {\n    return this.data;\n  }\n\n  immutApplyElementwise(f: (entry: number) => number): Matrix {\n    return this.applyElementwiseInto(f, this.clone());\n  }\n\n  applyElementwiseInto(f: (entry: number) => number, out: Matrix): Matrix {\n    if (!(this.rows === out.rows && this.columns === out.columns)) {\n      throw new TypeError(\n        \"Cannot apply \" +\n          f.name +\n          \" elementwise on a \" +\n          this.rows +\n          \"x\" +\n          this.columns +\n          \" matrix into a \" +\n          out.rows +\n          \"x\" +\n          out.columns +\n          \" matrix. Matrices must have the same dimensions.\"\n      );\n    }\n\n    const thisData = this.data;\n    const outData = out.data;\n    const outSize = outData.length;\n    for (let i = 0; i < outSize; i++) {\n      outData[i] = f(thisData[i]);\n    }\n    return out;\n  }\n\n  copyInto(out: Matrix): Matrix {\n    if (!(this.rows === out.rows && this.columns === out.columns)) {\n      throw new Error(\n        \"Cannot copy a \" +\n          this.rows +\n          \"x\" +\n          this.columns +\n          \" matrix into a \" +\n          out.rows +\n          \"x\" +\n          out.columns +\n          \" matrix.\"\n      );\n    }\n\n    const thisData = this.data;\n    const outData = out.data;\n    const outSize = outData.length;\n    for (let i = 0; i < outSize; i++) {\n      outData[i] = thisData[i];\n    }\n    return out;\n  }\n\n  setToZero(): void {\n    const thisData = this.data;\n    const thisSize = thisData.length;\n    for (let i = 0; i < thisSize; i++) {\n      thisData[i] = 0;\n    }\n  }\n\n  print(decimals: number): string {\n    const entries = Array.from(this.rowMajorOrderEntries());\n    const entryStrings = entries.map((entry) => entry.toFixed(decimals));\n    const entryStringLengths = entryStrings.map((s) => s.length);\n    const maxLength = Math.max(...entryStringLengths);\n\n    const topAndBottomBorder = \"-\".repeat(\n      this.columns * (maxLength + \" | \".length) - \" | \".length\n    );\n\n    let str = topAndBottomBorder + \"\\n\";\n\n    for (let r = 0; r < this.rows; r++) {\n      for (let c = 0; c < this.columns; c++) {\n        str +=\n          leftpad(entryStrings[r * this.columns + c], maxLength, \" \") + \" | \";\n      }\n\n      str = str.slice(0, -\" | \".length);\n\n      str += \"\\n\";\n    }\n\n    str += topAndBottomBorder;\n    return str;\n  }\n}\n\nfunction leftpad(s: string, minLength: number, fillCharacter: string): string {\n  const diff = minLength - s.length;\n  if (diff <= 0) {\n    return s;\n  }\n\n  return fillCharacter.repeat(diff) + s;\n}\n","import { Matrix } from \"../matrix\";\n\nexport interface LabeledImage {\n  rows: number;\n  columns: number;\n  inputs: Matrix;\n  label: number;\n}\n\nexport interface VectorLabeledImage {\n  rows: number;\n  columns: number;\n  inputs: Matrix;\n  outputs: Matrix;\n}\n\ninterface ImageMatrix {\n  rows: number;\n  columns: number;\n  matrix: Matrix;\n}\n\nexport interface AccuracyRate {\n  correct: number;\n  total: number;\n}\n\nconst Idx3FileFormat = {\n  MagicNumber: { offset: 0, requiredValue: 0x00000803 },\n  NumberOfImages: { offset: 4 },\n  NumberOfRows: { offset: 8 },\n  NumberOfColumns: { offset: 12 },\n} as const;\n\nconst Idx1FileFormat = {\n  MagicNumber: { offset: 0, requiredValue: 0x00000801 },\n  NumberOfLabels: { offset: 4 },\n} as const;\n\nexport function getLabeledImages(\n  imagesBuffer: ArrayBuffer,\n  labelsBuffer: ArrayBuffer\n): LabeledImage[] {\n  const images = getImages(imagesBuffer);\n  const labels = getLabels(labelsBuffer);\n\n  if (images.length !== labels.length) {\n    throw new Error(\n      \"There are \" +\n        images.length +\n        \" images, but \" +\n        labels.length +\n        \" labels. There must be the same amount of images and labels.\"\n    );\n  }\n\n  const labeledImages: LabeledImage[] = new Array(images.length);\n  for (let i = 0; i < images.length; i++) {\n    const { rows, columns, matrix } = images[i];\n    labeledImages[i] = { rows, columns, inputs: matrix, label: labels[i] };\n  }\n  return labeledImages;\n}\n\nfunction getImages(buffer: ArrayBuffer): ImageMatrix[] {\n  const bytes = new Uint8Array(buffer);\n\n  assertIdx3MagicNumberIsCorrect(bytes);\n\n  const numberOfImages = getInt32MsbFirst(\n    bytes,\n    Idx3FileFormat.NumberOfImages.offset\n  );\n  const rows = getInt32MsbFirst(bytes, Idx3FileFormat.NumberOfRows.offset);\n  const columns = getInt32MsbFirst(\n    bytes,\n    Idx3FileFormat.NumberOfColumns.offset\n  );\n  const size = rows * columns;\n\n  let imagesParsed = 0;\n  const images: ImageMatrix[] = new Array(numberOfImages);\n  const firstPixelIndex = Idx3FileFormat.NumberOfColumns.offset + 4;\n\n  while (imagesParsed < numberOfImages) {\n    const vectorEntries: number[] = new Array(size);\n    for (let j = 0; j < size; j++) {\n      vectorEntries[j] = bytes[firstPixelIndex + imagesParsed * size + j] / 255;\n    }\n\n    images[imagesParsed] = {\n      rows,\n      columns,\n      matrix: Matrix.columnVector(vectorEntries),\n    };\n    imagesParsed++;\n  }\n\n  return images;\n}\n\nfunction assertIdx3MagicNumberIsCorrect(bytes: Uint8Array): void {\n  const actual = getInt32MsbFirst(bytes, Idx3FileFormat.MagicNumber.offset);\n  const expected = Idx3FileFormat.MagicNumber.requiredValue;\n  if (actual !== expected) {\n    throw new Error(\n      \"The first 4 bytes of an idx3 file must be 0x\" +\n        expected.toString(16) +\n        \", but the first 4 bytes of the provided file were 0x\" +\n        actual.toString(16)\n    );\n  }\n}\n\nfunction getInt32MsbFirst(bytes: Uint8Array, offset: number): number {\n  return (\n    (bytes[offset] << 24) |\n    (bytes[offset + 1] << 16) |\n    (bytes[offset + 2] << 8) |\n    bytes[offset + 3]\n  );\n}\n\nfunction getLabels(buffer: ArrayBuffer): number[] {\n  const bytes = new Uint8Array(buffer);\n\n  assertIdx1MagicNumberIsCorrect(bytes);\n\n  const numberOfLabels = getInt32MsbFirst(\n    bytes,\n    Idx1FileFormat.NumberOfLabels.offset\n  );\n  const labels: number[] = new Array(numberOfLabels);\n  const firstLabelIndex = Idx1FileFormat.NumberOfLabels.offset + 4;\n  for (let i = 0; i < numberOfLabels; i++) {\n    labels[i] = bytes[firstLabelIndex + i];\n  }\n  return labels;\n}\n\nfunction assertIdx1MagicNumberIsCorrect(bytes: Uint8Array): void {\n  const actual = getInt32MsbFirst(bytes, Idx1FileFormat.MagicNumber.offset);\n  const expected = Idx1FileFormat.MagicNumber.requiredValue;\n  if (actual !== expected) {\n    throw new Error(\n      \"The first 4 bytes of an idx1 file must be 0x\" +\n        expected.toString(16) +\n        \", but the first 4 bytes of the provided file were 0x\" +\n        actual.toString(16)\n    );\n  }\n}\n\nexport function convertLabelToVector(image: LabeledImage): VectorLabeledImage {\n  const entries: number[] = new Array(10).fill(0);\n  entries[image.label] = 1;\n  const outputs = Matrix.columnVector(entries);\n  return {\n    rows: image.rows,\n    columns: image.columns,\n    inputs: image.inputs,\n    outputs,\n  };\n}\n\nexport function convertVectorToLabel(image: VectorLabeledImage): LabeledImage {\n  return {\n    rows: image.rows,\n    columns: image.columns,\n    inputs: image.inputs,\n    label: getLabel(image),\n  };\n}\n\nfunction getLabel(image: VectorLabeledImage): number {\n  const entries = image.outputs.rowMajorOrderEntries();\n  for (let i = 0; i < entries.length; i++) {\n    if (entries[i] === 1) {\n      return i;\n    }\n  }\n  throw new Error(\"A VectorLabeledImage has an output vector without a 1.\");\n}\n","import url from \"url\";\nimport {\n  convertLabelToVector,\n  getLabeledImages,\n  LabeledImage,\n  VectorLabeledImage,\n} from \".\";\n\nexport interface MnistData {\n  training: VectorLabeledImage[];\n  test: LabeledImage[];\n}\n\ndeclare const self: { location: Window[\"location\"] };\n\nconst { location } = self;\n\nconst TRAINING_IMAGES_URL = url.resolve(\n  location.href,\n  \"./assets/train60k-images-idx3-ubyte\"\n);\nconst TRAINING_LABELS_URL = url.resolve(\n  location.href,\n  \"./assets/train60k-labels-idx1-ubyte\"\n);\nconst TEST_IMAGES_URL = url.resolve(\n  location.href,\n  \"./assets/test10k-images-idx3-ubyte\"\n);\nconst TEST_LABELS_URL = url.resolve(\n  location.href,\n  \"./assets/test10k-labels-idx1-ubyte\"\n);\nconst trainingImagesProm: Promise<ArrayBuffer> = getArrayBuffer(\n  TRAINING_IMAGES_URL\n);\nconst trainingLabelsProm: Promise<ArrayBuffer> = getArrayBuffer(\n  TRAINING_LABELS_URL\n);\nconst testImagesProm: Promise<ArrayBuffer> = getArrayBuffer(TEST_IMAGES_URL);\nconst testLabelsProm: Promise<ArrayBuffer> = getArrayBuffer(TEST_LABELS_URL);\n\nfunction getArrayBuffer(url: string): Promise<ArrayBuffer> {\n  return fetch(url).then((response) => {\n    if (200 <= response.status && response.status <= 299) {\n      return response.arrayBuffer();\n    } else {\n      return getErrorMessage(response).then((errorMessage) =>\n        Promise.reject(\n          new Error(\n            \"Tried to fetch \" +\n              url +\n              \" but got the following error: \" +\n              errorMessage\n          )\n        )\n      );\n    }\n  });\n}\n\nfunction getErrorMessage(response: Response): Promise<string> {\n  const { status, statusText } = response;\n  return response\n    .text()\n    .then((text) => status + \" (\" + statusText + \"): \" + text);\n}\n\nexport const mnistProm: Promise<MnistData> = Promise.all([\n  trainingImagesProm,\n  trainingLabelsProm,\n  testImagesProm,\n  testLabelsProm,\n]).then(\n  ([\n    trainingImagesBuffer,\n    trainingLabelsBuffer,\n    testImagesBuffer,\n    testLabelsBuffer,\n  ]) => {\n    return {\n      training: getLabeledImages(\n        trainingImagesBuffer,\n        trainingLabelsBuffer\n      ).map(convertLabelToVector),\n      test: getLabeledImages(testImagesBuffer, testLabelsBuffer),\n    };\n  }\n);\n","import { LabeledImage, VectorLabeledImage, AccuracyRate } from \"../data\";\nimport { Matrix } from \"../matrix\";\nimport { DeepReadonly } from \"../deepReadonly\";\n\nexport interface Network {\n  readonly layerSizes: number[];\n\n  stochasticGradientDescent(\n    trainingData: VectorLabeledImage[],\n    hyperparams: StochasticGradientDescentHyperParameters,\n    evaluationData?: LabeledImage[]\n  ): void;\n\n  performForwardPass(inputColumnVector: Matrix): WeightedSumsAndActivations;\n\n  test(testData: LabeledImage[]): AccuracyRate;\n\n  getWeights(): DeepReadonly<MatrixMap>;\n\n  getBiases(): DeepReadonly<MatrixMap>;\n}\n\nexport interface WeightedSumsAndActivations {\n  weightedSums: MatrixMap;\n  activations: MatrixMap;\n}\n\n/**\n * `MatrixMap` differs from `ArrayLike<Matrix>` in that\n * indices start at `1`. Because the input layer (layer\n * `0`) does not have a weight matrix or bias matrix,\n * `MatrixMap[0]` will be undefined.\n */\nexport interface MatrixMap {\n  [layer: number]: Matrix;\n  length: number;\n}\n\nexport enum WeightInitializationMethod {\n  Uniform = \"Uniform\",\n  LargeGaussian = \"LargeGaussian\",\n  SmallGaussian = \"SmallGaussian\",\n}\n\nexport interface StochasticGradientDescentHyperParameters {\n  batchSize: number;\n  epochs: number;\n  learningRate: number;\n  regularizationRate: number;\n  momentumCoefficient: number;\n}\n","/** Generates a random float on the interval [-1, 1). */\nexport function uniformRandom(): number {\n  return Math.random() * 2 - 1;\n}\n\n// https://en.wikipedia.org/wiki/Box-Muller_transform\nexport function normalRandom(mean: number = 0, variance: number = 1): number {\n  let u1 = 0;\n  let u2 = 0;\n\n  // Convert [0,1) to (0,1)\n  while (u1 === 0) {\n    u1 = Math.random();\n  }\n  while (u2 === 0) {\n    u2 = Math.random();\n  }\n\n  const z1 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);\n  return variance * z1 + mean;\n}\n","import { MatrixMap, WeightInitializationMethod } from \".\";\nimport { VectorLabeledImage } from \"../data\";\nimport { uniformRandom, normalRandom } from \"../random\";\n\nexport interface Gradients {\n  weightGradients: MatrixMap;\n  biasGradients: MatrixMap;\n}\n\nexport function divideIntoMiniBatches(\n  trainingData: VectorLabeledImage[],\n  miniBatchSize: number\n): VectorLabeledImage[][] {\n  shuffle(trainingData);\n  const miniBatches: VectorLabeledImage[][] = [];\n  for (let i = 0; i < trainingData.length; i += miniBatchSize) {\n    miniBatches.push(trainingData.slice(i, i + miniBatchSize));\n  }\n  return miniBatches;\n}\n\nfunction shuffle(arr: unknown[]): void {\n  const SHUFFLE_TIMES = 512;\n\n  for (let n = 0; n < SHUFFLE_TIMES; n++) {\n    for (let i = arr.length - 1; i >= 1; i--) {\n      let j = randInt(i + 1);\n      const temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n    }\n  }\n}\n\nfunction randInt(exclMax: number): number {\n  return Math.floor(Math.random() * exclMax);\n}\n\nexport function argmax(arr: ArrayLike<number>): number {\n  let maxIndex = 0;\n  let max = arr[maxIndex];\n  for (let i = 1; i < arr.length; i++) {\n    const value = arr[i];\n    if (value > max) {\n      max = value;\n      maxIndex = i;\n    }\n  }\n  return maxIndex;\n}\n\nexport function initializeWeights(\n  method: WeightInitializationMethod,\n  weights: MatrixMap\n): void {\n  for (let i = 1; i < weights.length; i++) {\n    const matrix = weights[i];\n    const initializer: () => number = (() => {\n      switch (method) {\n        case WeightInitializationMethod.Uniform:\n          return uniformRandom;\n        case WeightInitializationMethod.LargeGaussian:\n          return () => normalRandom(0, 1);\n        case WeightInitializationMethod.SmallGaussian:\n          return () => normalRandom(0, 1 / Math.sqrt(matrix.columns));\n      }\n    })();\n    matrix.applyElementwiseInto(initializer, matrix);\n  }\n}\n","import {\n  MatrixMap,\n  Network,\n  StochasticGradientDescentHyperParameters,\n  WeightedSumsAndActivations,\n  WeightInitializationMethod,\n} from \"..\";\nimport { AccuracyRate, LabeledImage, VectorLabeledImage } from \"../../data\";\nimport { DeepReadonly } from \"../../deepReadonly\";\nimport { Matrix } from \"../../matrix\";\nimport {\n  argmax,\n  divideIntoMiniBatches,\n  Gradients,\n  initializeWeights,\n} from \"../utils\";\n\n/** Cross-entropy cost, sigmoid activation, L2 regularization, momentum */\nexport class Chapter3CrossEntropyL2NetworkMomentum implements Network {\n  private numberOfLayers: number;\n  private weights: MatrixMap;\n  private biases: MatrixMap;\n  private weightVelocities: MatrixMap;\n  private biasVelocities: MatrixMap;\n  private log: (accuracyRate: AccuracyRate, epoch: number) => void;\n\n  private temp_totalWeightGradients: MatrixMap;\n  private temp_totalBiasGradients: MatrixMap;\n\n  private temp_weightedSums: MatrixMap;\n  private temp_activations: MatrixMap;\n\n  private temp_errors: MatrixMap;\n  private temp_weightGradients: MatrixMap;\n  private temp_biasGradients: MatrixMap;\n  private temp_transposedActivations: MatrixMap;\n  private temp_weightCosts: MatrixMap;\n  private temp_transposedWeights: MatrixMap;\n  private temp_sigmaPrimeOfWeightedSums: MatrixMap;\n\n  public readonly layerSizes: number[];\n\n  static fromWeightsAndBiases(weights: MatrixMap, biases: MatrixMap): Network {\n    return new Chapter3CrossEntropyL2NetworkMomentum(weights, biases);\n  }\n\n  static fromLayerSizes(\n    layerSizes: number[],\n    initializationMethod: WeightInitializationMethod,\n    log?: (accuracyRate: AccuracyRate, epoch: number) => void\n  ): Network {\n    const numberOfLayers = layerSizes.length;\n\n    const weights: MatrixMap = new Array(numberOfLayers);\n    const biases: MatrixMap = new Array(numberOfLayers);\n    for (let outputLayer = 1; outputLayer < numberOfLayers; outputLayer++) {\n      const inputLayer = outputLayer - 1;\n      const outputLayerSize = layerSizes[outputLayer];\n      const inputLayerSize = layerSizes[inputLayer];\n      weights[outputLayer] = Matrix.zeros(outputLayerSize, inputLayerSize);\n      biases[outputLayer] = Matrix.zeros(outputLayerSize, 1);\n    }\n\n    initializeWeights(initializationMethod, weights);\n\n    return new Chapter3CrossEntropyL2NetworkMomentum(weights, biases, log);\n  }\n\n  private constructor(\n    weights: MatrixMap,\n    biases: MatrixMap,\n    log?: (accuracyRate: AccuracyRate, epoch: number) => void\n  ) {\n    const layerSizes = [weights[1].columns];\n    for (let i = 1; i < weights.length; i++) {\n      layerSizes.push(weights[i].rows);\n    }\n\n    this.layerSizes = layerSizes;\n    this.numberOfLayers = layerSizes.length;\n    this.weights = weights;\n    this.biases = biases;\n    this.weightVelocities = getZeroMatrixMap(weights);\n    this.biasVelocities = getZeroMatrixMap(biases);\n    this.log = log || (() => {});\n\n    this.temp_totalWeightGradients = getZeroMatrixMap(weights);\n    this.temp_totalBiasGradients = getZeroMatrixMap(biases);\n\n    {\n      const weightedSums = [];\n      const activations = [Matrix.zeros(weights[1].columns, 1)];\n\n      for (\n        let outputLayer = 1;\n        outputLayer < this.numberOfLayers;\n        outputLayer++\n      ) {\n        weightedSums[outputLayer] = Matrix.zeros(weights[outputLayer].rows, 1);\n        activations[outputLayer] = Matrix.zeros(weights[outputLayer].rows, 1);\n      }\n\n      this.temp_weightedSums = weightedSums;\n      this.temp_activations = activations;\n    }\n\n    this.temp_errors = getZeroMatrixMap(this.temp_weightedSums);\n    this.temp_weightGradients = getZeroMatrixMap(weights);\n    this.temp_biasGradients = getZeroMatrixMap(biases);\n\n    {\n      const activations = this.temp_activations;\n      const transposedActivations: MatrixMap = new Array(activations.length);\n\n      for (\n        let outputLayer = 0;\n        outputLayer < activations.length;\n        outputLayer++\n      ) {\n        transposedActivations[outputLayer] = Matrix.zeros(\n          activations[outputLayer].columns,\n          activations[outputLayer].rows\n        );\n      }\n\n      this.temp_transposedActivations = transposedActivations;\n    }\n\n    this.temp_weightCosts = getZeroMatrixMap(this.temp_weightGradients);\n\n    {\n      const { weights } = this;\n      const transposedWeights: MatrixMap = new Array(weights.length);\n      for (let i = 1; i < weights.length; i++) {\n        transposedWeights[i] = Matrix.zeros(\n          weights[i].columns,\n          weights[i].rows\n        );\n      }\n      this.temp_transposedWeights = transposedWeights;\n    }\n\n    this.temp_sigmaPrimeOfWeightedSums = getZeroMatrixMap(\n      this.temp_weightedSums\n    );\n  }\n\n  stochasticGradientDescent(\n    trainingData: VectorLabeledImage[],\n    hyperParams: StochasticGradientDescentHyperParameters,\n    testData?: LabeledImage[]\n  ): void {\n    const {\n      batchSize,\n      epochs,\n      learningRate,\n      momentumCoefficient,\n    } = hyperParams;\n    const trainingDataSize = trainingData.length;\n\n    for (let epoch = 0; epoch < epochs; epoch++) {\n      const miniBatches = divideIntoMiniBatches(trainingData, batchSize);\n      for (const miniBatch of miniBatches) {\n        const { weightGradients, biasGradients } = this.getTotalGradients(\n          miniBatch,\n          hyperParams.regularizationRate,\n          trainingDataSize\n        );\n\n        for (let i = 1; i < this.numberOfLayers; i++) {\n          weightGradients[i].mutMultiplyScalar(learningRate / miniBatch.length);\n          biasGradients[i].mutMultiplyScalar(learningRate / miniBatch.length);\n\n          this.weightVelocities[i]\n            .mutMultiplyScalar(momentumCoefficient)\n            .mutSubtract(weightGradients[i]);\n          this.biasVelocities[i]\n            .mutMultiplyScalar(momentumCoefficient)\n            .mutSubtract(biasGradients[i]);\n\n          this.weights[i].mutAdd(this.weightVelocities[i]);\n          this.biases[i].mutAdd(this.biasVelocities[i]);\n\n          //   this.weights[i].mutSubtract(weightGradients[i]);\n          //   this.biases[i].mutSubtract(biasGradients[i]);\n        }\n      }\n\n      if (testData !== undefined) {\n        const accuracyRate = this.test(testData);\n        this.log(accuracyRate, epoch);\n      }\n    }\n  }\n\n  private getTotalGradients(\n    miniBatch: VectorLabeledImage[],\n    regularizationRate: number,\n    trainingDataSize: number\n  ): Gradients {\n    const {\n      weightGradients: totalWeightGradients,\n      biasGradients: totalBiasGradients,\n    } = this.resetTotalGradientTemps();\n\n    for (const image of miniBatch) {\n      const { weightGradients, biasGradients } = this.getGradients(\n        image,\n        regularizationRate,\n        trainingDataSize\n      );\n      for (let i = 1; i < this.numberOfLayers; i++) {\n        totalWeightGradients[i].mutAdd(weightGradients[i]);\n        totalBiasGradients[i].mutAdd(biasGradients[i]);\n      }\n    }\n\n    return {\n      weightGradients: totalWeightGradients,\n      biasGradients: totalBiasGradients,\n    };\n  }\n\n  private resetTotalGradientTemps(): Gradients {\n    const numberOfLayers = this.layerSizes.length;\n    const weightGradients = this.temp_totalWeightGradients;\n    const biasGradients = this.temp_totalBiasGradients;\n    for (let i = 1; i < numberOfLayers; i++) {\n      weightGradients[i].setToZero();\n      biasGradients[i].setToZero();\n    }\n    return { weightGradients, biasGradients };\n  }\n\n  private getGradients(\n    image: VectorLabeledImage,\n    regularizationRate: number,\n    trainingDataSize: number\n  ): Gradients {\n    const { numberOfLayers } = this;\n\n    const { weightedSums, activations } = this.performForwardPass(image.inputs);\n    const errors = this.temp_errors;\n    const weightGradients = this.temp_weightGradients;\n    const biasGradients = this.temp_biasGradients;\n\n    const lastLayerError = activations[this.numberOfLayers - 1].subtractInto(\n      image.outputs,\n      errors[numberOfLayers - 1]\n    );\n\n    lastLayerError\n      .multiplyInto(\n        activations[numberOfLayers - 2].transposeInto(\n          this.temp_transposedActivations[numberOfLayers - 2]\n        ),\n        weightGradients[numberOfLayers - 1]\n      )\n      .mutAdd(\n        this.weights[numberOfLayers - 1].multiplyScalarInto(\n          regularizationRate / trainingDataSize,\n          this.temp_weightCosts[numberOfLayers - 1]\n        )\n      );\n\n    lastLayerError.copyInto(biasGradients[numberOfLayers - 1]);\n\n    for (let i = this.numberOfLayers - 2; i >= 1; i--) {\n      const error = this.weights[i + 1]\n        .transposeInto(this.temp_transposedWeights[i + 1])\n        .multiplyInto(errors[i + 1], errors[i])\n        .mutHadamard(\n          weightedSums[i].applyElementwiseInto(\n            sigmaPrime,\n            this.temp_sigmaPrimeOfWeightedSums[i]\n          )\n        );\n\n      error\n        .multiplyInto(\n          activations[i - 1].transposeInto(\n            this.temp_transposedActivations[i - 1]\n          ),\n          weightGradients[i]\n        )\n        .mutAdd(\n          this.weights[i].multiplyScalarInto(\n            regularizationRate / trainingDataSize,\n            this.temp_weightCosts[i]\n          )\n        );\n\n      error.copyInto(biasGradients[i]);\n    }\n\n    return { weightGradients, biasGradients };\n  }\n\n  performForwardPass(inputs: Matrix): WeightedSumsAndActivations {\n    const weightedSums = this.temp_weightedSums;\n    const activations = this.temp_activations;\n\n    activations[0] = inputs;\n\n    for (\n      let outputLayer = 1;\n      outputLayer < this.numberOfLayers;\n      outputLayer++\n    ) {\n      const inputLayer = outputLayer - 1;\n      const weightedSum = this.weights[outputLayer]\n        .multiplyInto(activations[inputLayer], weightedSums[outputLayer])\n        .mutAdd(this.biases[outputLayer]);\n      weightedSum.applyElementwiseInto(sigma, activations[outputLayer]);\n    }\n    return { weightedSums, activations };\n  }\n\n  test(testData: LabeledImage[]): AccuracyRate {\n    let correctClassifications = 0;\n    for (const image of testData) {\n      const { activations } = this.performForwardPass(image.inputs);\n      const prediction = argmax(\n        activations[this.numberOfLayers - 1].rowMajorOrderEntries()\n      );\n      if (prediction === image.label) {\n        correctClassifications++;\n      }\n    }\n    return { correct: correctClassifications, total: testData.length };\n  }\n\n  getWeights(): DeepReadonly<MatrixMap> {\n    return this.weights;\n  }\n\n  getBiases(): DeepReadonly<MatrixMap> {\n    return this.biases;\n  }\n}\n\nfunction sigma(z: number): number {\n  return 1 / (1 + Math.exp(-z));\n}\n\nfunction sigmaPrime(z: number): number {\n  const sigmaZ = sigma(z);\n  return sigmaZ * (1 - sigmaZ);\n}\n\nfunction getZeroMatrixMap(map: MatrixMap): MatrixMap {\n  const zeroMatrices: MatrixMap = [];\n  for (let i = 1; i < map.length; i++) {\n    const matrix = map[i];\n    zeroMatrices[i] = Matrix.zeros(matrix.rows, matrix.columns);\n  }\n  return zeroMatrices;\n}\n","import { MatrixMap, Network, WeightInitializationMethod } from \".\";\nimport { Chapter3CrossEntropyL2NetworkMomentum } from \"./networks/ch3crossEntropyL2Momentum\";\n\nexport interface NetworkFactory {\n  fromLayerSizes(\n    layerSizes: number[],\n    initializationMethod: WeightInitializationMethod\n  ): Network;\n  fromWeightsAndBiases(weights: MatrixMap, biases: MatrixMap): Network;\n}\n\n/**\n * At any given time, the entire web app uses one and only\n * one neural network implementation.\n *\n * All other files will depend on `networkFactory`, which will\n * allow me to easily change which network I'm using by changing\n * only one variable.\n * Otherwise, if I wanted to change from using `NetworkX`\n * to `NetworkY`, I would have to go through the entire src\n * folder and replace every occurrence of `NetworkX` with\n * `NetworkY`.\n */\nexport const networkFactory: NetworkFactory = {\n  fromLayerSizes(\n    layerSizes: number[],\n    initializationMethod: WeightInitializationMethod\n  ): Network {\n    return Chapter3CrossEntropyL2NetworkMomentum.fromLayerSizes(\n      layerSizes,\n      initializationMethod\n    );\n  },\n  fromWeightsAndBiases(weights: MatrixMap, biases: MatrixMap): Network {\n    return Chapter3CrossEntropyL2NetworkMomentum.fromWeightsAndBiases(\n      weights,\n      biases\n    );\n  },\n};\n","import { AccuracyRate } from \"./data\";\nimport { StochasticGradientDescentHyperParameters } from \"./network\";\n\nexport enum WorkerMessageType {\n  StartTrainingRequest,\n  TrainingEpochCompleteNotification,\n  TerminateTrainingRequest,\n  TerminateTrainingResponse,\n\n  StartTestingRequest,\n  TestCompleteNotification,\n}\n\nexport type NetworkTrainerRequest =\n  | StartTrainingRequest\n  | TerminateTrainingRequest;\n\nexport type NetworkTrainerNotification =\n  | TrainingEpochCompleteNotification\n  | TerminateTrainingResponse;\n\nexport interface StartTrainingRequest {\n  messageType: WorkerMessageType.StartTrainingRequest;\n\n  networkBuffer: ArrayBuffer;\n  hyperParams: StochasticGradientDescentHyperParameters;\n}\n\nexport interface TrainingEpochCompleteNotification {\n  messageType: WorkerMessageType.TrainingEpochCompleteNotification;\n\n  accuracyRate: AccuracyRate;\n  epoch: number;\n}\n\nexport interface TerminateTrainingRequest {\n  messageType: WorkerMessageType.TerminateTrainingRequest;\n}\n\nexport interface TerminateTrainingResponse {\n  messageType: WorkerMessageType.TerminateTrainingResponse;\n\n  networkBuffer: ArrayBuffer;\n}\n\nexport interface StartTestingRequest {\n  messageType: WorkerMessageType.StartTestingRequest;\n\n  networkBuffer: ArrayBuffer;\n}\n\nexport interface TestCompleteNotification {\n  messageType: WorkerMessageType.TestCompleteNotification;\n  accuracyRate: AccuracyRate;\n}\n","import { Matrix } from \"./matrix\";\nimport { MatrixMap, Network } from \"./network\";\nimport { networkFactory } from \"./network/networkFactory\";\n\nexport function serializeNetwork(network: Network): ArrayBuffer {\n  const entries = getEntries(network);\n\n  const numberOfBytesForSizes =\n    (1 + network.layerSizes.length) * Uint32Array.BYTES_PER_ELEMENT;\n\n  const buffer = new ArrayBuffer(\n    numberOfBytesForSizes + entries.length * entries.BYTES_PER_ELEMENT\n  );\n\n  const uints = new Uint32Array(\n    buffer,\n    0,\n    numberOfBytesForSizes / Uint32Array.BYTES_PER_ELEMENT\n  );\n\n  uints[0] = network.layerSizes.length;\n\n  for (let i = 0; i < network.layerSizes.length; i++) {\n    uints[1 + i] = network.layerSizes[i];\n  }\n\n  const floats = new Float64Array(entries);\n  putBuffer(floats.buffer, buffer, numberOfBytesForSizes);\n\n  return buffer;\n}\n\nfunction getEntries(network: Network): Float64Array {\n  const weights = network.getWeights();\n  const biases = network.getBiases();\n\n  let entryCount = 0;\n\n  for (let i = 1; i < weights.length; i++) {\n    const weightMatrix = weights[i];\n    const weightMatrixSize = weightMatrix.rows * weightMatrix.columns;\n    entryCount += weightMatrixSize;\n\n    const biasMatrix = biases[i];\n    const biasMatrixSize = biasMatrix.rows * biasMatrix.columns;\n    entryCount += biasMatrixSize;\n  }\n\n  const entries = new Float64Array(entryCount);\n\n  let cursor = 0;\n  for (let i = 1; i < weights.length; i++) {\n    const weightMatrixEntries = weights[i].rowMajorOrderEntries();\n    entries.set(weightMatrixEntries, cursor);\n    cursor += weightMatrixEntries.length;\n\n    const biasMatrixEntries = biases[i].rowMajorOrderEntries();\n    entries.set(biasMatrixEntries, cursor);\n    cursor += biasMatrixEntries.length;\n  }\n\n  return entries;\n}\n\nfunction putBuffer(\n  src: ArrayBuffer,\n  dest: ArrayBuffer,\n  byteOffset: number = 0\n): void {\n  const srcU8s = new Uint8Array(src);\n  const destU8s = new Uint8Array(dest);\n  for (let i = 0; i < srcU8s.length; i++) {\n    destU8s[byteOffset + i] = srcU8s[i];\n  }\n}\n\nexport function deserializeNetwork(buffer: ArrayBuffer): Network {\n  const numberOfLayers = new Uint32Array(buffer, 0, 1)[0];\n  const layerSizes = new Uint32Array(buffer, 4, numberOfLayers);\n  const entries = new Float64Array(\n    buffer.slice(Uint32Array.BYTES_PER_ELEMENT * (1 + numberOfLayers))\n  );\n\n  const weights: MatrixMap = [];\n  const biases: MatrixMap = [];\n\n  let cursor = 0;\n  for (let i = 1; i < layerSizes.length; i++) {\n    const outputLayerSize = layerSizes[i];\n    const inputLayerSize = layerSizes[i - 1];\n\n    {\n      const rows = outputLayerSize;\n      const columns = inputLayerSize;\n      const size = rows * columns;\n      weights[i] = Matrix.fromRowMajorOrderEntries(\n        rows,\n        columns,\n        toArray(entries.subarray(cursor, cursor + size))\n      );\n\n      cursor += size;\n    }\n\n    {\n      const rows = outputLayerSize;\n      biases[i] = Matrix.fromRowMajorOrderEntries(\n        rows,\n        1,\n        toArray(entries.subarray(cursor, cursor + rows))\n      );\n\n      cursor += rows;\n    }\n  }\n\n  return networkFactory.fromWeightsAndBiases(weights, biases);\n}\n\nfunction toArray(floats: Float64Array): number[] {\n  const arr = new Array(floats.length);\n  for (let i = 0; i < floats.length; i++) {\n    arr[i] = floats[i];\n  }\n  return arr;\n}\n","import { Option, Result } from \"rusty-ts\";\nimport { AccuracyRate } from \"./data\";\nimport { MnistData } from \"./data/mnist\";\nimport { Matrix } from \"./matrix\";\nimport { Network, WeightInitializationMethod } from \"./network\";\nimport { NetworkTester, NetworkTrainer } from \"./networkServices\";\n\nexport type AppState =\n  | CreateNetworkState\n  | NetworkMainMenuState\n  | HyperParameterMenuState\n  | TrainingInProgressState\n  | TestState\n  | ViewState\n  | CropState\n  | MnistLoadingErrorState;\n\nexport enum StateType {\n  CreateNetwork,\n  NetworkMainMenu,\n  HyperParameterMenu,\n  TrainingInProgress,\n  Test,\n  View,\n  Crop,\n\n  MnistLoadingError,\n}\n\nexport interface StateMap {\n  [StateType.CreateNetwork]: CreateNetworkState;\n  [StateType.NetworkMainMenu]: NetworkMainMenuState;\n  [StateType.HyperParameterMenu]: HyperParameterMenuState;\n  [StateType.TrainingInProgress]: TrainingInProgressState;\n  [StateType.Test]: TestState;\n  [StateType.View]: ViewState;\n  [StateType.Crop]: CropState;\n\n  [StateType.MnistLoadingError]: MnistLoadingErrorState;\n}\n\nexport interface CreateNetworkState {\n  mnist: Option<MnistData>;\n\n  stateType: StateType.CreateNetwork;\n\n  hiddenLayerSizeInputValues: string[];\n  weightInitializationMethod: WeightInitializationMethod;\n  previousNetwork: Option<Network>;\n}\nexport interface NetworkMainMenuState {\n  mnist: Option<MnistData>;\n\n  stateType: StateType.NetworkMainMenu;\n\n  network: Network;\n}\n\nexport interface HyperParameterMenuState {\n  mnist: Option<MnistData>;\n\n  stateType: StateType.HyperParameterMenu;\n\n  network: Network;\n\n  batchSizeInputValue: string;\n  epochsInputValue: string;\n  learningRateInputValue: string;\n  regularizationRateInputValue: string;\n  momentumCoefficientInputValue: string;\n}\n\nexport interface TrainingInProgressState {\n  mnist: Option<MnistData>;\n\n  stateType: StateType.TrainingInProgress;\n\n  network: Network;\n\n  networkTrainer: NetworkTrainer;\n  epochAccuracyRates: EpochAccuracyRate[];\n}\n\nexport interface EpochAccuracyRate extends AccuracyRate {\n  epoch: number;\n}\n\nexport interface TestState {\n  mnist: Option<MnistData>;\n\n  stateType: StateType.Test;\n\n  network: Network;\n\n  accuracyRate: Result<AccuracyRate, NetworkTester>;\n}\n\nexport interface ViewState {\n  mnist: Option<MnistData>;\n\n  stateType: StateType.View;\n\n  network: Network;\n\n  viewedIndex: number;\n  customImages: CustomImage[];\n}\n\nexport interface CustomImage {\n  u8Matrix: Matrix;\n  label: number;\n}\n\nexport interface CropState {\n  mnist: Option<MnistData>;\n\n  stateType: StateType.Crop;\n\n  network: Network;\n  customImages: CustomImage[];\n\n  uploadedImage: HTMLImageElement;\n  darknessThreshold: number;\n  cropSquare: Square;\n  pendingCropAdjustment: Option<SquareAdjustment>;\n  hoveredOverDraggable: Option<Draggable>;\n  shouldInvertImage: boolean;\n  labelInputValue: string;\n}\n\nexport interface Square {\n  x: number;\n  y: number;\n  size: number;\n}\n\nexport interface SquareAdjustment {\n  dragged: Draggable;\n  startX: number;\n  startY: number;\n  currentX: number;\n  currentY: number;\n}\n\nexport enum Draggable {\n  TopLeftCorner,\n  TopRightCorner,\n  BottomRightCorner,\n  BottomLeftCorner,\n\n  EntireSquare,\n}\n\nexport type Corner =\n  | Draggable.TopLeftCorner\n  | Draggable.TopRightCorner\n  | Draggable.BottomRightCorner\n  | Draggable.BottomLeftCorner;\n\nexport interface MnistLoadingErrorState {\n  mnist: Option<MnistData>;\n\n  stateType: StateType.MnistLoadingError;\n\n  errorMessage: string;\n}\n","import { Option, option } from \"rusty-ts\";\nimport { Matrix } from \"./matrix\";\nimport { Network } from \"./network\";\nimport { CustomImage } from \"./state\";\nimport { deserializeNetwork, serializeNetwork } from \"./networkSerializer\";\n\nexport interface StateSaver<T> {\n  getState(): Option<T>;\n  saveState(state: T): void;\n}\n\nenum LocalStorageKeys {\n  CustomImages = \"CustomImages\",\n  NeuralNetwork = \"NeuralNetwork\",\n}\n\n// 28*28 pixels plus 1 label\nconst BYTES_PER_IMAGE = 28 * 28 + 1;\n\nexport const imageSaver: StateSaver<CustomImage[]> = {\n  getState(): Option<CustomImage[]> {\n    const stateStr = localStorage.getItem(LocalStorageKeys.CustomImages);\n    if (stateStr === null) {\n      return option.none();\n    } else {\n      const bytes = decodeBytes(stateStr);\n\n      if (bytes.length % BYTES_PER_IMAGE !== 0) {\n        throw new Error(\n          \"Cannot decode image bytes because there are \" +\n            bytes.length +\n            \" bytes, and that number is not a multiple of 784.\"\n        );\n      }\n\n      const numberOfImages = bytes.length / BYTES_PER_IMAGE;\n\n      const byteVectors: CustomImage[] = new Array(numberOfImages);\n      for (let i = 0; i < numberOfImages; i++) {\n        const imageBytes = bytes.subarray(\n          i * BYTES_PER_IMAGE,\n          i * BYTES_PER_IMAGE + 784\n        );\n        const u8Matrix = Matrix.columnVector(toArray(imageBytes));\n        byteVectors[i] = { u8Matrix, label: bytes[i * BYTES_PER_IMAGE + 784] };\n      }\n      return option.some(byteVectors);\n    }\n  },\n\n  saveState(images: CustomImage[]): void {\n    const bytes = new Uint8Array(images.length * BYTES_PER_IMAGE);\n    for (let i = 0; i < images.length; i++) {\n      const image = images[i];\n      bytes.set(image.u8Matrix.rowMajorOrderEntries(), i * BYTES_PER_IMAGE);\n      bytes[i * BYTES_PER_IMAGE + 784] = image.label;\n    }\n\n    const stateStr = encodeBytes(bytes);\n    localStorage.setItem(LocalStorageKeys.CustomImages, stateStr);\n  },\n};\n\nexport const networkSaver: StateSaver<Network> = {\n  getState(): Option<Network> {\n    const stateStr = localStorage.getItem(LocalStorageKeys.NeuralNetwork);\n    if (stateStr === null) {\n      return option.none();\n    } else {\n      const bytes = decodeBytes(stateStr);\n      const network = deserializeNetwork(bytes.buffer);\n      return option.some(network);\n    }\n  },\n\n  saveState(network: Network): void {\n    const buffer = serializeNetwork(network);\n    const stateStr = encodeBytes(new Uint8Array(buffer));\n    localStorage.setItem(LocalStorageKeys.NeuralNetwork, stateStr);\n  },\n};\n\nfunction decodeBytes(str: string): Uint8Array {\n  const numberOfBytes = toU32((str.charCodeAt(0) << 16) | str.charCodeAt(1));\n  const bytes = new Uint8Array(numberOfBytes);\n\n  for (let i = 0; i < numberOfBytes; i++) {\n    const code = str.charCodeAt(2 + Math.floor(i / 2));\n\n    const byte = i % 2 === 0 ? code >>> 8 : code;\n\n    bytes[i] = byte;\n  }\n  return bytes;\n}\n\nfunction toU32(n: number): number {\n  const arr = new Uint32Array(1);\n  arr[0] = n;\n  return arr[0];\n}\n\nfunction toArray(u8s: Uint8Array): number[] {\n  const arr: number[] = new Array(u8s.length);\n  for (let i = 0; i < u8s.length; i++) {\n    arr[i] = u8s[i];\n  }\n  return arr;\n}\n\nfunction encodeBytes(bytes: Uint8Array): string {\n  const numberOfBytes = bytes.length;\n  const u16s = new Array(Math.ceil(numberOfBytes / 2));\n\n  for (let i = 0; i < bytes.length; i++) {\n    const byte = bytes[i];\n    if (i % 2 === 0) {\n      u16s[i / 2] = byte << 8;\n    } else {\n      u16s[(i - 1) / 2] |= byte;\n    }\n  }\n\n  return (\n    String.fromCharCode(\n      numberOfBytes >>> 16,\n      numberOfBytes & 0b0000_0000_0000_0000_1111_1111_1111_1111\n    ) + stringifyU16s(u16s)\n  );\n}\n\nfunction stringifyU16s(u16s: number[]): string {\n  try {\n    // This will crash in some browsers if\n    // `u16s` is too large.\n    return String.fromCharCode(...u16s);\n  } catch {\n    let out = \"\";\n\n    for (let i = 0; i < u16s.length; i++) {\n      out += String.fromCharCode(u16s[i]);\n    }\n\n    return out;\n  }\n}\n","// eslint-disable-next-line import/no-webpack-loader-syntax\nimport NetworkTesterWorker from \"worker-loader!./networkTester\";\n\nexport default NetworkTesterWorker;\n","// eslint-disable-next-line import/no-webpack-loader-syntax\nimport NetworkTrainerWorker from \"worker-loader!./networkTrainer\";\n\nexport default NetworkTrainerWorker;\n","import { AccuracyRate } from \"./data\";\nimport { Network, StochasticGradientDescentHyperParameters } from \"./network\";\nimport { deserializeNetwork, serializeNetwork } from \"./networkSerializer\";\nimport {\n  NetworkTrainerNotification,\n  StartTestingRequest,\n  StartTrainingRequest,\n  TerminateTrainingRequest,\n  TerminateTrainingResponse,\n  TestCompleteNotification,\n  TrainingEpochCompleteNotification,\n  WorkerMessageType,\n} from \"./workerMessages\";\nimport NetworkTesterWorker from \"./workers/networkTester.importable\";\nimport NetworkTrainerWorker from \"./workers/networkTrainer.importable\";\n\nexport interface NetworkTrainer {\n  start(): void;\n  terminate(): void;\n}\n\nexport interface NetworkTester {\n  start(): void;\n  terminate(): void;\n}\n\nexport interface NetworkTrainerListeners {\n  onEpochComplete(accuracyRate: AccuracyRate, epoch: number): void;\n  onTerminate(network: Network): void;\n}\n\nexport interface NetworkTesterListeners {\n  onComplete(rate: AccuracyRate): void;\n}\n\nexport function trainNetwork(\n  network: Network,\n  hyperParams: StochasticGradientDescentHyperParameters,\n  listeners: NetworkTrainerListeners\n): NetworkTrainer {\n  const worker = new NetworkTrainerWorker();\n\n  worker.addEventListener(\"message\", (event) => {\n    const { data } = event;\n    if (data !== null && \"object\" === typeof data && \"messageType\" in data) {\n      const message: NetworkTrainerNotification = data;\n      switch (message.messageType) {\n        case WorkerMessageType.TrainingEpochCompleteNotification:\n          notifyListenersOfEpochCompletion(message);\n          break;\n        case WorkerMessageType.TerminateTrainingResponse:\n          notifyListenersOfTermination(message);\n          break;\n\n        default: {\n          // Force exhaustive matching\n\n          // eslint-disable-next-line\n          const unreachable: never = message;\n        }\n      }\n    }\n  });\n\n  return { start: startTraining, terminate: stopTrainingAfterThisEpoch };\n\n  function notifyListenersOfEpochCompletion(\n    message: TrainingEpochCompleteNotification\n  ): void {\n    listeners.onEpochComplete(message.accuracyRate, message.epoch);\n  }\n\n  function notifyListenersOfTermination(\n    message: TerminateTrainingResponse\n  ): void {\n    const updatedNetwork = deserializeNetwork(message.networkBuffer);\n    listeners.onTerminate(updatedNetwork);\n\n    worker.terminate();\n  }\n\n  function startTraining(): void {\n    const message: StartTrainingRequest = {\n      messageType: WorkerMessageType.StartTrainingRequest,\n      networkBuffer: serializeNetwork(network),\n      hyperParams,\n    };\n    worker.postMessage(message, [message.networkBuffer]);\n  }\n\n  function stopTrainingAfterThisEpoch(): void {\n    const message: TerminateTrainingRequest = {\n      messageType: WorkerMessageType.TerminateTrainingRequest,\n    };\n    worker.postMessage(message);\n  }\n}\n\nexport function testNetwork(\n  network: Network,\n  listeners: NetworkTesterListeners\n): NetworkTrainer {\n  const worker = new NetworkTesterWorker();\n\n  worker.addEventListener(\"message\", (event) => {\n    const { data } = event;\n    if (data !== null && \"object\" === typeof data && \"messageType\" in data) {\n      const message: TestCompleteNotification = data;\n      notifyListenersOfTestingCompletion(message);\n    }\n  });\n\n  return { start: startTesting, terminate: terminateWorker };\n\n  function notifyListenersOfTestingCompletion(\n    message: TestCompleteNotification\n  ): void {\n    listeners.onComplete(message.accuracyRate);\n\n    worker.terminate();\n  }\n\n  function startTesting(): void {\n    const message: StartTestingRequest = {\n      messageType: WorkerMessageType.StartTestingRequest,\n      networkBuffer: serializeNetwork(network),\n    };\n    worker.postMessage(message, [message.networkBuffer]);\n  }\n\n  function terminateWorker(): void {\n    worker.terminate();\n  }\n}\n","import React from \"react\";\nimport { option, Option, result } from \"rusty-ts\";\nimport \"./App.css\";\nimport { AccuracyRate, LabeledImage } from \"./data\";\nimport { MnistData, mnistProm } from \"./data/mnist\";\nimport { Matrix } from \"./matrix\";\nimport {\n  Network,\n  StochasticGradientDescentHyperParameters,\n  WeightInitializationMethod,\n} from \"./network\";\nimport { networkFactory } from \"./network/networkFactory\";\nimport { testNetwork, trainNetwork } from \"./networkServices\";\nimport {\n  AppState,\n  Corner,\n  CreateNetworkState,\n  CropState,\n  CustomImage,\n  Draggable,\n  HyperParameterMenuState,\n  MnistLoadingErrorState,\n  NetworkMainMenuState,\n  Square,\n  SquareAdjustment,\n  StateMap,\n  StateType,\n  TestState,\n  TrainingInProgressState,\n  ViewState,\n} from \"./state\";\nimport { imageSaver, networkSaver } from \"./stateSavers\";\n\ninterface Rect {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\ninterface CornerAdjustment extends SquareAdjustment {\n  dragged: Corner;\n}\n\nexport default class App extends React.Component<{}, AppState> {\n  private viewImageCanvasRef: React.RefObject<HTMLCanvasElement>;\n  private customImageInputRef: React.RefObject<HTMLInputElement>;\n  private cropImageCanvasRef: React.RefObject<HTMLCanvasElement>;\n\n  constructor(props: {}) {\n    super(props);\n\n    this.state = getInitialState();\n\n    this.viewImageCanvasRef = React.createRef();\n    this.customImageInputRef = React.createRef();\n    this.cropImageCanvasRef = React.createRef();\n\n    this.bindMethods();\n\n    (window as any).app = this;\n  }\n\n  bindMethods(): void {\n    this.onWeightInitializationMethodChange = this.onWeightInitializationMethodChange.bind(\n      this\n    );\n    this.onCreateNetworkClick = this.onCreateNetworkClick.bind(this);\n    this.onTrainClick = this.onTrainClick.bind(this);\n    this.onTestClick = this.onTestClick.bind(this);\n    this.onViewClick = this.onViewClick.bind(this);\n    this.onResetClick = this.onResetClick.bind(this);\n    this.onBatchSizeInputValueChange = this.onBatchSizeInputValueChange.bind(\n      this\n    );\n    this.onEpochsInputValueChange = this.onEpochsInputValueChange.bind(this);\n    this.onLearningRateInputValueChange = this.onLearningRateInputValueChange.bind(\n      this\n    );\n    this.onRegularizationRateInputValueChange = this.onRegularizationRateInputValueChange.bind(\n      this\n    );\n    this.onMomentumCoefficientInputValueChange = this.onMomentumCoefficientInputValueChange.bind(\n      this\n    );\n    this.onStartTrainingClick = this.onStartTrainingClick.bind(this);\n    this.onEpochComplete = this.onEpochComplete.bind(this);\n    this.onTrainerTerminate = this.onTrainerTerminate.bind(this);\n    this.onExitHyperParameterMenuClick = this.onExitHyperParameterMenuClick.bind(\n      this\n    );\n    this.onStopTrainingClick = this.onStopTrainingClick.bind(this);\n    this.onTestMenuExitClick = this.onTestMenuExitClick.bind(this);\n    this.onExitViewMenuClick = this.onExitViewMenuClick.bind(this);\n    this.onPreviousImageClick = this.onPreviousImageClick.bind(this);\n    this.onNextImageClick = this.onNextImageClick.bind(this);\n    this.onCustomImageInputChange = this.onCustomImageInputChange.bind(this);\n    this.enterCropMenu = this.enterCropMenu.bind(this);\n    this.onCropImageCanvasPointerDown = this.onCropImageCanvasPointerDown.bind(\n      this\n    );\n    this.onCropImageCanvasPointerMove = this.onCropImageCanvasPointerMove.bind(\n      this\n    );\n    this.onCropImageCanvasPointerUp = this.onCropImageCanvasPointerUp.bind(\n      this\n    );\n    this.onShouldInvertInputChange = this.onShouldInvertInputChange.bind(this);\n    this.onDarknessThresholdChange = this.onDarknessThresholdChange.bind(this);\n    this.onCustomImageLabelInputValueChange = this.onCustomImageLabelInputValueChange.bind(\n      this\n    );\n    this.onDeleteCustomImageClick = this.onDeleteCustomImageClick.bind(this);\n    this.onAddCustomImageClick = this.onAddCustomImageClick.bind(this);\n  }\n\n  componentDidMount(): void {\n    mnistProm.then(\n      (mnist) => {\n        this.setState({ mnist: option.some(mnist) });\n      },\n\n      (error: Error) => {\n        const newState: MnistLoadingErrorState = {\n          mnist: option.none(),\n          stateType: StateType.MnistLoadingError,\n          errorMessage: error.message,\n        };\n        this.saveState(newState);\n      }\n    );\n  }\n\n  saveState(state: AppState): void {\n    this.setState(state);\n\n    if (\"network\" in state) {\n      const { network } = state;\n      networkSaver.saveState(network);\n    }\n\n    if (\"customImages\" in state) {\n      const { customImages } = state;\n      imageSaver.saveState(customImages);\n    }\n  }\n\n  render(): React.ReactElement {\n    const { state } = this;\n    switch (state.stateType) {\n      case StateType.CreateNetwork:\n        return this.renderCreateNetworkMenu(state);\n      case StateType.NetworkMainMenu:\n        return this.renderNetworkMainMenu(state);\n      case StateType.HyperParameterMenu:\n        return this.renderHyperParameterMenu(state);\n      case StateType.TrainingInProgress:\n        return this.renderTrainingInProgressMenu(state);\n      case StateType.Test:\n        return this.renderTestMenu(state);\n      case StateType.View:\n        return this.renderViewMenu(state);\n      case StateType.Crop:\n        return this.renderCropMenu(state);\n\n      case StateType.MnistLoadingError:\n        return this.renderMnistLoadingErrorScreen(state);\n    }\n  }\n\n  renderCreateNetworkMenu(state: CreateNetworkState): React.ReactElement {\n    return (\n      <div className=\"App\">\n        <h1>\n          {state.previousNetwork.match({\n            none: () => \"Create network\",\n            some: () => \"Reset network\",\n          })}\n        </h1>\n\n        {state.previousNetwork.match({\n          none: () => null,\n          some: (network) => (\n            <button onClick={() => this.cancelNetworkReset(network)}>\n              Cancel\n            </button>\n          ),\n        })}\n\n        <h2>Layers:</h2>\n        <ol>\n          <li>\n            Input layer: 784 neurons\n            <button onClick={() => this.addLayerBelow(0, state)}>\n              Add layer below\n            </button>\n          </li>\n\n          {state.hiddenLayerSizeInputValues.map((value, hiddenLayerIndex) => {\n            const layerIndex = hiddenLayerIndex + 1;\n            return (\n              <li key={layerIndex}>\n                <label>\n                  Hidden layer:{\" \"}\n                  <input\n                    type=\"text\"\n                    className={isPositiveIntStr(value) ? \"\" : \"InvalidInput\"}\n                    value={value}\n                    onChange={(e) =>\n                      this.changeLayerSizeValue(\n                        layerIndex,\n                        e.target.value,\n                        state\n                      )\n                    }\n                  />{\" \"}\n                  neurons\n                </label>\n                <button onClick={() => this.addLayerBelow(layerIndex, state)}>\n                  Add layer below\n                </button>\n                <button onClick={() => this.deleteLayer(layerIndex, state)}>\n                  Delete layer\n                </button>\n              </li>\n            );\n          })}\n\n          <li>Output layer: 10 neurons</li>\n        </ol>\n\n        <label>\n          Weight initialization method:{\" \"}\n          <select\n            value={state.weightInitializationMethod}\n            onChange={this.onWeightInitializationMethodChange}\n          >\n            <option value={WeightInitializationMethod.Uniform}>\n              Uniform random on [-1, 1)\n            </option>\n            <option value={WeightInitializationMethod.LargeGaussian}>\n              Large Gaussian\n            </option>\n            <option value={WeightInitializationMethod.SmallGaussian}>\n              Small Gaussian\n            </option>\n          </select>\n        </label>\n\n        <button\n          onClick={this.onCreateNetworkClick}\n          disabled={state.hiddenLayerSizeInputValues.some(\n            (value) => !isPositiveIntStr(value)\n          )}\n        >\n          Create network\n        </button>\n      </div>\n    );\n  }\n\n  renderNetworkMainMenu(state: NetworkMainMenuState): React.ReactElement {\n    return (\n      <div className=\"App\">\n        <h1>Explore your neural network</h1>\n        <h2>Neurons in each layer: {state.network.layerSizes.join(\", \")}</h2>\n\n        <button onClick={this.onTrainClick}>Train</button>\n        <button onClick={this.onTestClick}>Test</button>\n        <button onClick={this.onViewClick}>View</button>\n        <button onClick={this.onResetClick}>Reset</button>\n      </div>\n    );\n  }\n\n  renderHyperParameterMenu(state: HyperParameterMenuState): React.ReactElement {\n    return (\n      <div className=\"App\">\n        <h1>Train (stochastic gradient descent)</h1>\n\n        <button onClick={this.onExitHyperParameterMenuClick}>Cancel</button>\n\n        <h2>Hyperparameters:</h2>\n\n        <label>\n          Batch size:{\" \"}\n          <input\n            type=\"text\"\n            className={\n              isPositiveIntStr(state.batchSizeInputValue) ? \"\" : \"InvalidInput\"\n            }\n            value={state.batchSizeInputValue}\n            onChange={this.onBatchSizeInputValueChange}\n          />\n        </label>\n\n        <label>\n          Epochs:{\" \"}\n          <input\n            type=\"text\"\n            className={\n              isPositiveIntStr(state.epochsInputValue) ? \"\" : \"InvalidInput\"\n            }\n            value={state.epochsInputValue}\n            onChange={this.onEpochsInputValueChange}\n          />\n        </label>\n\n        <label>\n          Learning rate:{\" \"}\n          <input\n            type=\"text\"\n            className={\n              isPositiveNumStr(state.learningRateInputValue)\n                ? \"\"\n                : \"InvalidInput\"\n            }\n            value={state.learningRateInputValue}\n            onChange={this.onLearningRateInputValueChange}\n          />\n        </label>\n\n        <label>\n          Regularization rate:{\" \"}\n          <input\n            type=\"text\"\n            className={\n              isPositiveNumStr(state.regularizationRateInputValue)\n                ? \"\"\n                : \"InvalidInput\"\n            }\n            value={state.regularizationRateInputValue}\n            onChange={this.onRegularizationRateInputValueChange}\n          />\n        </label>\n\n        <label>\n          Momentum coefficient:{\" \"}\n          <input\n            type=\"text\"\n            className={\n              isOnInclusiveUnitInterval(+state.momentumCoefficientInputValue)\n                ? \"\"\n                : \"InvalidInput\"\n            }\n            value={state.momentumCoefficientInputValue}\n            onChange={this.onMomentumCoefficientInputValueChange}\n          />\n          <input\n            type=\"range\"\n            className={\n              isOnInclusiveUnitInterval(+state.momentumCoefficientInputValue)\n                ? \"\"\n                : \"InvalidInput\"\n            }\n            min={0}\n            max={1}\n            step={0.001}\n            value={\n              Number.isNaN(+state.momentumCoefficientInputValue)\n                ? 0\n                : +state.momentumCoefficientInputValue\n            }\n            onChange={this.onMomentumCoefficientInputValueChange}\n          />\n        </label>\n\n        <button\n          onClick={this.onStartTrainingClick}\n          disabled={\n            !(\n              isPositiveIntStr(state.batchSizeInputValue) &&\n              isPositiveIntStr(state.epochsInputValue) &&\n              isPositiveNumStr(state.learningRateInputValue) &&\n              isPositiveNumStr(state.regularizationRateInputValue) &&\n              isOnInclusiveUnitInterval(+state.momentumCoefficientInputValue)\n            )\n          }\n        >\n          Start\n        </button>\n      </div>\n    );\n  }\n\n  renderTrainingInProgressMenu(\n    state: TrainingInProgressState\n  ): React.ReactElement {\n    return (\n      <div className=\"App\">\n        <h1>Training in progress...</h1>\n\n        <h2>Logs:</h2>\n        {state.epochAccuracyRates\n          .slice()\n          .sort((a, b) => a.epoch - b.epoch)\n          .map((rate) => (\n            <div key={rate.epoch}>\n              Epoch {rate.epoch}: {rate.correct} / {rate.total}\n            </div>\n          ))}\n\n        <button onClick={this.onStopTrainingClick}>\n          Stop training after current epoch\n        </button>\n      </div>\n    );\n  }\n\n  renderTestMenu(state: TestState): React.ReactElement {\n    return (\n      <div className=\"App\">\n        <h1>Test results:</h1>\n\n        {state.accuracyRate.match({\n          err: () => <p>Running tests...</p>,\n          ok: (rate) => (\n            <p>\n              {rate.correct} / {rate.total} correct\n            </p>\n          ),\n        })}\n\n        <button onClick={this.onTestMenuExitClick}>Back</button>\n      </div>\n    );\n  }\n\n  renderViewMenu(state: ViewState): React.ReactElement {\n    return state.mnist.match({\n      none: () => (\n        <div className=\"App\">\n          <p>Loading...</p>\n        </div>\n      ),\n      some: (mnist) => {\n        const viewedImage: LabeledImage = getViewedImage(state, mnist);\n        const guess = guessDigit(state.network, viewedImage.inputs);\n\n        return (\n          <div className=\"App\">\n            <h1>View classifications</h1>\n            <button onClick={this.onExitViewMenuClick}>Back</button>\n\n            <div>\n              <button onClick={this.onPreviousImageClick}>Previous</button>{\" \"}\n              Image {state.viewedIndex + 1} /{\" \"}\n              {mnist.test.length + state.customImages.length}{\" \"}\n              <button onClick={this.onNextImageClick}>Next</button>\n            </div>\n\n            <canvas ref={this.viewImageCanvasRef}></canvas>\n\n            <div\n              className={\n                guess.digit === viewedImage.label ? \"\" : \"IncorrectGuess\"\n              }\n            >\n              Guess: {guess.digit} ({(guess.confidence * 100).toFixed(2)}%\n              confident)\n            </div>\n\n            <div>Actual: {viewedImage.label}</div>\n\n            {state.viewedIndex >= mnist.test.length && (\n              <div>\n                <button onClick={this.onDeleteCustomImageClick}>\n                  Delete this image\n                </button>\n              </div>\n            )}\n\n            <div>\n              <label>\n                Upload your own image:{\" \"}\n                <input\n                  type=\"file\"\n                  accept=\"image/*\"\n                  ref={this.customImageInputRef}\n                  onChange={this.onCustomImageInputChange}\n                />\n              </label>\n            </div>\n          </div>\n        );\n      },\n    });\n  }\n\n  renderCropMenu(state: CropState): React.ReactElement {\n    return (\n      <div\n        className=\"App\"\n        onMouseMove={this.onCropImageCanvasPointerMove}\n        onTouchMove={this.onCropImageCanvasPointerMove}\n        onMouseUp={this.onCropImageCanvasPointerUp}\n        onTouchEnd={this.onCropImageCanvasPointerUp}\n      >\n        <h1>Crop image</h1>\n\n        <div>\n          <canvas\n            ref={this.cropImageCanvasRef}\n            className={\n              \"CropImageCanvas WhiteBackground\" +\n              state.hoveredOverDraggable.match({\n                none: () => \"\",\n                some: (draggable): string => {\n                  switch (draggable) {\n                    case Draggable.TopLeftCorner:\n                    case Draggable.BottomRightCorner:\n                      return \" NwseResizeCursor\";\n                    case Draggable.TopRightCorner:\n                    case Draggable.BottomLeftCorner:\n                      return \" NeswResizeCursor\";\n                    case Draggable.EntireSquare:\n                      return \" MoveCursor\";\n                  }\n                },\n              })\n            }\n            onMouseDown={this.onCropImageCanvasPointerDown}\n            onTouchStart={this.onCropImageCanvasPointerDown}\n          ></canvas>\n        </div>\n\n        <div>\n          <label>\n            Invert{\" \"}\n            <input\n              type=\"checkbox\"\n              checked={state.shouldInvertImage}\n              onChange={this.onShouldInvertInputChange}\n            />\n          </label>\n        </div>\n\n        <div>\n          <label>\n            Darkness threshold:{\" \"}\n            <input\n              type=\"range\"\n              value={state.darknessThreshold}\n              min={0}\n              max={1}\n              step={0.001}\n              onChange={this.onDarknessThresholdChange}\n            />\n          </label>\n        </div>\n\n        <div>\n          <label>\n            Label:{\" \"}\n            <input\n              type=\"text\"\n              className={isDigit(state.labelInputValue) ? \"\" : \"InvalidInput\"}\n              value={state.labelInputValue}\n              onChange={this.onCustomImageLabelInputValueChange}\n            />\n          </label>\n        </div>\n\n        <button\n          disabled={!isDigit(state.labelInputValue)}\n          onClick={this.onAddCustomImageClick}\n        >\n          Add\n        </button>\n      </div>\n    );\n  }\n\n  renderMnistLoadingErrorScreen(\n    state: MnistLoadingErrorState\n  ): React.ReactElement {\n    return (\n      <div className=\"App\">\n        <h1>Error loading MNIST data set:</h1>\n        <p>{state.errorMessage}</p>\n      </div>\n    );\n  }\n\n  componentDidUpdate(): void {\n    const { state } = this;\n    state.mnist.ifSome((mnist) => {\n      if (state.stateType === StateType.View) {\n        const canvas = this.viewImageCanvasRef.current;\n        if (canvas !== null) {\n          const viewedImage = getViewedImage(state, mnist);\n          paintImage(viewedImage, canvas);\n        }\n      } else if (state.stateType === StateType.Crop) {\n        const canvas = this.cropImageCanvasRef.current;\n        if (canvas !== null) {\n          const adjustedCropSquare = state.pendingCropAdjustment.match({\n            none: () => state.cropSquare,\n            some: (adjustment) => {\n              return applyPendingAdjustment(\n                state.cropSquare,\n                adjustment,\n                canvas.width,\n                canvas.height\n              );\n            },\n          });\n          paintImageAndCropSquare(\n            state.uploadedImage,\n            adjustedCropSquare,\n            canvas,\n            state.shouldInvertImage,\n            state.darknessThreshold\n          );\n        }\n      }\n    });\n  }\n\n  cancelNetworkReset(network: Network): void {\n    const newState: NetworkMainMenuState = {\n      mnist: this.state.mnist,\n\n      stateType: StateType.NetworkMainMenu,\n\n      network,\n    };\n    this.saveState(newState);\n  }\n\n  changeLayerSizeValue(\n    changedLayerIndex: number,\n    newValue: string,\n    state: CreateNetworkState\n  ): void {\n    this.saveState({\n      ...state,\n      hiddenLayerSizeInputValues: state.hiddenLayerSizeInputValues.map(\n        (value, hiddenLayerIndex) => {\n          const layerIndex = hiddenLayerIndex + 1;\n          if (layerIndex === changedLayerIndex) {\n            return newValue;\n          } else {\n            return value;\n          }\n        }\n      ),\n    });\n  }\n\n  addLayerBelow(layerIndex: number, state: CreateNetworkState): void {\n    this.saveState({\n      ...state,\n      hiddenLayerSizeInputValues: state.hiddenLayerSizeInputValues\n        .slice(0, layerIndex)\n        .concat([\"16\"], state.hiddenLayerSizeInputValues.slice(layerIndex)),\n    });\n  }\n\n  deleteLayer(layerIndex: number, state: CreateNetworkState): void {\n    const hiddenLayerIndex = layerIndex - 1;\n    this.saveState({\n      ...state,\n      hiddenLayerSizeInputValues: state.hiddenLayerSizeInputValues\n        .slice(0, hiddenLayerIndex)\n        .concat(state.hiddenLayerSizeInputValues.slice(hiddenLayerIndex + 1)),\n    });\n  }\n\n  onWeightInitializationMethodChange(\n    event: React.ChangeEvent<HTMLSelectElement>\n  ): void {\n    const state = this.expectState(StateType.CreateNetwork);\n    const newState: CreateNetworkState = {\n      ...state,\n      weightInitializationMethod: event.target\n        .value as WeightInitializationMethod,\n    };\n    this.saveState(newState);\n  }\n\n  onCreateNetworkClick(): void {\n    const state = this.expectState(StateType.CreateNetwork);\n    if (state.hiddenLayerSizeInputValues.every(isPositiveIntStr)) {\n      const hiddenLayerSizes: number[] = state.hiddenLayerSizeInputValues.map(\n        (str) => +str\n      );\n      const layerSizes = [784, ...hiddenLayerSizes, 10];\n\n      const newState: NetworkMainMenuState = {\n        mnist: this.state.mnist,\n\n        stateType: StateType.NetworkMainMenu,\n\n        network: networkFactory.fromLayerSizes(\n          layerSizes,\n          state.weightInitializationMethod\n        ),\n      };\n\n      this.saveState(newState);\n    }\n  }\n\n  expectState<T extends StateType>(stateType: T): StateMap[T] {\n    const { state } = this;\n    if (state.stateType === stateType) {\n      return state as StateMap[T];\n    }\n    throw new Error(\n      \"Expecting a state of type \" +\n        StateType[stateType] +\n        \" but got state of type \" +\n        StateType[state.stateType]\n    );\n  }\n\n  onTrainClick(): void {\n    const state = this.expectState(StateType.NetworkMainMenu);\n    const newState: HyperParameterMenuState = {\n      mnist: state.mnist,\n\n      stateType: StateType.HyperParameterMenu,\n\n      network: state.network,\n\n      batchSizeInputValue: \"10\",\n      epochsInputValue: \"30\",\n      learningRateInputValue: \"0.5\",\n      regularizationRateInputValue: \"5.0\",\n      momentumCoefficientInputValue: \"0.0\",\n    };\n    this.saveState(newState);\n  }\n\n  onTestClick(): void {\n    const state = this.expectState(StateType.NetworkMainMenu);\n\n    const networkTester = testNetwork(state.network, {\n      onComplete: (accuracyRate) => {\n        this.updateState(StateType.Test, {\n          accuracyRate: result.ok(accuracyRate),\n        });\n      },\n    });\n\n    const newState: TestState = {\n      mnist: state.mnist,\n\n      stateType: StateType.Test,\n\n      network: state.network,\n\n      accuracyRate: result.err(networkTester),\n    };\n\n    this.saveState(newState);\n\n    networkTester.start();\n  }\n\n  updateState<T extends StateType>(\n    stateType: T,\n    updateOrUpdater:\n      | Partial<StateMap[T]>\n      | ((prevState: StateMap[T]) => Partial<StateMap[T]>)\n  ): void {\n    const { state } = this;\n    if (state.stateType === stateType) {\n      if (\"function\" === typeof updateOrUpdater) {\n        this.saveState({ ...state, ...updateOrUpdater(state as StateMap[T]) });\n      } else {\n        this.saveState({ ...state, ...updateOrUpdater });\n      }\n    }\n  }\n\n  onViewClick(): void {\n    const state = this.expectState(StateType.NetworkMainMenu);\n    const newState: ViewState = {\n      mnist: state.mnist,\n\n      stateType: StateType.View,\n\n      network: state.network,\n\n      viewedIndex: 0,\n      customImages: imageSaver.getState().unwrapOr([]),\n    };\n    this.saveState(newState);\n  }\n\n  onResetClick(): void {\n    const state = this.expectState(StateType.NetworkMainMenu);\n    const newState: CreateNetworkState = {\n      mnist: state.mnist,\n\n      stateType: StateType.CreateNetwork,\n\n      hiddenLayerSizeInputValues: [\"30\"],\n      weightInitializationMethod: WeightInitializationMethod.SmallGaussian,\n      previousNetwork: option.some(state.network),\n    };\n    this.saveState(newState);\n  }\n\n  onBatchSizeInputValueChange(\n    event: React.ChangeEvent<HTMLInputElement>\n  ): void {\n    const state = this.expectState(StateType.HyperParameterMenu);\n    const newState: HyperParameterMenuState = {\n      ...state,\n      batchSizeInputValue: event.target.value,\n    };\n    this.saveState(newState);\n  }\n\n  onEpochsInputValueChange(event: React.ChangeEvent<HTMLInputElement>): void {\n    const state = this.expectState(StateType.HyperParameterMenu);\n    const newState: HyperParameterMenuState = {\n      ...state,\n      epochsInputValue: event.target.value,\n    };\n    this.saveState(newState);\n  }\n\n  onLearningRateInputValueChange(\n    event: React.ChangeEvent<HTMLInputElement>\n  ): void {\n    const state = this.expectState(StateType.HyperParameterMenu);\n    const newState: HyperParameterMenuState = {\n      ...state,\n      learningRateInputValue: event.target.value,\n    };\n    this.saveState(newState);\n  }\n\n  onRegularizationRateInputValueChange(\n    event: React.ChangeEvent<HTMLInputElement>\n  ): void {\n    const state = this.expectState(StateType.HyperParameterMenu);\n    const newState: HyperParameterMenuState = {\n      ...state,\n      regularizationRateInputValue: event.target.value,\n    };\n    this.saveState(newState);\n  }\n\n  onMomentumCoefficientInputValueChange(\n    event: React.ChangeEvent<HTMLInputElement>\n  ): void {\n    const state = this.expectState(StateType.HyperParameterMenu);\n    const newState: HyperParameterMenuState = {\n      ...state,\n      momentumCoefficientInputValue: event.target.value,\n    };\n    this.saveState(newState);\n  }\n\n  onStartTrainingClick(): void {\n    const state = this.expectState(StateType.HyperParameterMenu);\n\n    const hyperParams: StochasticGradientDescentHyperParameters = {\n      batchSize: +state.batchSizeInputValue,\n      epochs: +state.epochsInputValue,\n      learningRate: +state.learningRateInputValue,\n      regularizationRate: +state.regularizationRateInputValue,\n      momentumCoefficient: +state.momentumCoefficientInputValue,\n    };\n\n    const networkTrainer = trainNetwork(state.network, hyperParams, {\n      onEpochComplete: this.onEpochComplete,\n\n      onTerminate: this.onTrainerTerminate,\n    });\n\n    const newState: TrainingInProgressState = {\n      mnist: state.mnist,\n\n      stateType: StateType.TrainingInProgress,\n\n      network: state.network,\n\n      networkTrainer,\n      epochAccuracyRates: [],\n    };\n\n    this.saveState(newState);\n\n    networkTrainer.start();\n  }\n\n  onEpochComplete(accuracyRate: AccuracyRate, epoch: number): void {\n    this.updateState(StateType.TrainingInProgress, (prevState) => ({\n      epochAccuracyRates: prevState.epochAccuracyRates.concat([\n        { ...accuracyRate, epoch },\n      ]),\n    }));\n  }\n\n  onTrainerTerminate(updatedNetwork: Network): void {\n    const state = this.expectState(StateType.TrainingInProgress);\n    const newState: NetworkMainMenuState = {\n      mnist: state.mnist,\n\n      stateType: StateType.NetworkMainMenu,\n\n      network: updatedNetwork,\n    };\n    this.saveState(newState);\n  }\n\n  onExitHyperParameterMenuClick(): void {\n    const state = this.expectState(StateType.HyperParameterMenu);\n    const newState: NetworkMainMenuState = {\n      mnist: state.mnist,\n\n      stateType: StateType.NetworkMainMenu,\n\n      network: state.network,\n    };\n    this.saveState(newState);\n  }\n\n  onStopTrainingClick(): void {\n    const state = this.expectState(StateType.TrainingInProgress);\n    state.networkTrainer.terminate();\n  }\n\n  onTestMenuExitClick(): void {\n    const state = this.expectState(StateType.Test);\n\n    state.accuracyRate.ifErr((tester) => {\n      tester.terminate();\n    });\n\n    const newState: NetworkMainMenuState = {\n      mnist: state.mnist,\n\n      stateType: StateType.NetworkMainMenu,\n\n      network: state.network,\n    };\n    this.saveState(newState);\n  }\n\n  onExitViewMenuClick(): void {\n    const state = this.expectState(StateType.View);\n\n    const newState: NetworkMainMenuState = {\n      mnist: state.mnist,\n\n      stateType: StateType.NetworkMainMenu,\n\n      network: state.network,\n    };\n    this.saveState(newState);\n  }\n\n  onPreviousImageClick(): void {\n    const state = this.expectState(StateType.View);\n    state.mnist.ifSome((mnist) => {\n      const numberOfImages = mnist.test.length + state.customImages.length;\n      const newIndex =\n        state.viewedIndex === 0 ? numberOfImages - 1 : state.viewedIndex - 1;\n      this.saveState({ ...state, viewedIndex: newIndex });\n    });\n  }\n\n  onNextImageClick(): void {\n    const state = this.expectState(StateType.View);\n    state.mnist.ifSome((mnist) => {\n      const numberOfImages = mnist.test.length + state.customImages.length;\n      const newIndex =\n        state.viewedIndex === numberOfImages - 1 ? 0 : state.viewedIndex + 1;\n      this.saveState({ ...state, viewedIndex: newIndex });\n    });\n  }\n\n  onCustomImageInputChange(): void {\n    const input = this.customImageInputRef.current;\n    if (input !== null && input.files !== null && input.files.length > 0) {\n      readFileAsHtmlImage(input.files[0]).then(this.enterCropMenu);\n    }\n  }\n\n  enterCropMenu(uploadedImage: HTMLImageElement): void {\n    const state = this.expectState(StateType.View);\n    const newState: CropState = {\n      mnist: state.mnist,\n\n      stateType: StateType.Crop,\n\n      network: state.network,\n      customImages: state.customImages,\n\n      uploadedImage,\n      darknessThreshold: getAverageDarkness(uploadedImage),\n      cropSquare: {\n        x: 0,\n        y: 0,\n        size: Math.min(uploadedImage.width, uploadedImage.height),\n      },\n      pendingCropAdjustment: option.none(),\n      hoveredOverDraggable: option.none(),\n      shouldInvertImage: false,\n      labelInputValue: \"\",\n    };\n    this.saveState(newState);\n  }\n\n  onCropImageCanvasPointerDown(\n    event:\n      | React.MouseEvent<HTMLCanvasElement>\n      | React.TouchEvent<HTMLCanvasElement>\n  ): void {\n    const state = this.expectState(StateType.Crop);\n    const square = state.cropSquare;\n\n    const canvas = this.cropImageCanvasRef.current!;\n    const { x, y } = getLocalPointerCoordinates(event, canvas);\n    const rect = canvas.getBoundingClientRect();\n    const scale = canvas.width / rect.width;\n    const localRadius = CropMenuConfig.GlobalCornerHandleRadius * scale;\n\n    const optDragged: Option<Draggable> = (() => {\n      if (Math.hypot(x - square.x, y - square.y) <= localRadius) {\n        return option.some(Draggable.TopLeftCorner);\n      } else if (\n        Math.hypot(x - (square.x + square.size), y - square.y) <= localRadius\n      ) {\n        return option.some(Draggable.TopRightCorner);\n      } else if (\n        Math.hypot(\n          x - (square.x + square.size),\n          y - (square.y + square.size)\n        ) <= localRadius\n      ) {\n        return option.some(Draggable.BottomRightCorner);\n      } else if (\n        Math.hypot(x - square.x, y - (square.y + square.size)) <= localRadius\n      ) {\n        return option.some(Draggable.BottomLeftCorner);\n      } else if (\n        x > square.x &&\n        x < square.x + square.size &&\n        y > square.y &&\n        y < square.y + square.size\n      ) {\n        return option.some(Draggable.EntireSquare);\n      } else {\n        return option.none();\n      }\n    })();\n\n    this.saveState({\n      ...state,\n      pendingCropAdjustment: optDragged.map((dragged) => ({\n        dragged,\n        startX: x,\n        startY: y,\n        currentX: x,\n        currentY: y,\n      })),\n    });\n  }\n\n  onCropImageCanvasPointerMove(\n    event: React.MouseEvent | React.TouchEvent\n  ): void {\n    const state = this.expectState(StateType.Crop);\n    const canvas = this.cropImageCanvasRef.current!;\n    const current = getLocalPointerCoordinates(event, canvas);\n\n    state.pendingCropAdjustment.match({\n      some: (oldAdjustment) => {\n        const updatedAdjustment: SquareAdjustment = {\n          ...oldAdjustment,\n          currentX: current.x,\n          currentY: current.y,\n        };\n\n        this.saveState({\n          ...state,\n          pendingCropAdjustment: option.some(updatedAdjustment),\n        });\n\n        const adjustedCropSquare = applyPendingAdjustment(\n          state.cropSquare,\n          updatedAdjustment,\n          canvas.width,\n          canvas.height\n        );\n        paintImageAndCropSquare(\n          state.uploadedImage,\n          adjustedCropSquare,\n          canvas,\n          state.shouldInvertImage,\n          state.darknessThreshold\n        );\n      },\n\n      none: () => {\n        const rect = canvas.getBoundingClientRect();\n        const scale = canvas.width / rect.width;\n        const localRadius = CropMenuConfig.GlobalCornerHandleRadius * scale;\n        this.saveState({\n          ...state,\n          hoveredOverDraggable: getHoveredOverDraggable(\n            state.cropSquare,\n            current.x,\n            current.y,\n            localRadius\n          ),\n        });\n      },\n    });\n  }\n\n  onCropImageCanvasPointerUp(): void {\n    const state = this.expectState(StateType.Crop);\n    const canvas = this.cropImageCanvasRef.current!;\n    const updatedCropSquare = state.pendingCropAdjustment.match({\n      none: () => state.cropSquare,\n      some: (adjustment) =>\n        applyPendingAdjustment(\n          state.cropSquare,\n          adjustment,\n          canvas.width,\n          canvas.height\n        ),\n    });\n\n    this.saveState({\n      ...state,\n      pendingCropAdjustment: option.none(),\n      cropSquare: updatedCropSquare,\n    });\n  }\n\n  onShouldInvertInputChange(event: React.ChangeEvent<HTMLInputElement>): void {\n    const state = this.expectState(StateType.Crop);\n    const newState: CropState = {\n      ...state,\n      shouldInvertImage: event.target.checked,\n    };\n    this.saveState(newState);\n  }\n\n  onDarknessThresholdChange(event: React.ChangeEvent<HTMLInputElement>): void {\n    const state = this.expectState(StateType.Crop);\n    const newThreshold = +event.target.value;\n    const newState: CropState = { ...state, darknessThreshold: newThreshold };\n    this.saveState(newState);\n    paintImageAndCropSquare(\n      state.uploadedImage,\n      state.cropSquare,\n      this.cropImageCanvasRef.current!,\n      state.shouldInvertImage,\n      newThreshold\n    );\n  }\n\n  onCustomImageLabelInputValueChange(\n    event: React.ChangeEvent<HTMLInputElement>\n  ): void {\n    const state = this.expectState(StateType.Crop);\n    const newState: CropState = {\n      ...state,\n      labelInputValue: event.target.value,\n    };\n    this.saveState(newState);\n  }\n\n  onAddCustomImageClick(): void {\n    const state = this.expectState(StateType.Crop);\n\n    if (!isDigit(state.labelInputValue)) {\n      return;\n    }\n\n    state.mnist.ifSome((mnist) => {\n      const label = +state.labelInputValue;\n      const newImage = getCustomImage(\n        state,\n        label,\n        state.shouldInvertImage,\n        state.darknessThreshold\n      );\n      const updatedCustomImages = state.customImages.concat([newImage]);\n      const newImageIndex = mnist.test.length + updatedCustomImages.length - 1;\n      const newState: ViewState = {\n        mnist: state.mnist,\n\n        stateType: StateType.View,\n\n        network: state.network,\n\n        viewedIndex: newImageIndex,\n        customImages: updatedCustomImages,\n      };\n      this.saveState(newState);\n    });\n  }\n\n  onDeleteCustomImageClick(): void {\n    const state = this.expectState(StateType.View);\n    state.mnist.ifSome((mnist) => {\n      const customImageIndex = state.viewedIndex - mnist.test.length;\n      const newCustomImages = state.customImages\n        .slice(0, customImageIndex)\n        .concat(state.customImages.slice(customImageIndex + 1));\n      const newState: ViewState = {\n        ...state,\n        customImages: newCustomImages,\n        viewedIndex: state.viewedIndex - 1,\n      };\n      this.saveState(newState);\n    });\n  }\n}\n\nfunction getInitialState(): AppState {\n  return networkSaver.getState().match({\n    none: (): CreateNetworkState => ({\n      mnist: option.none(),\n\n      stateType: StateType.CreateNetwork,\n\n      hiddenLayerSizeInputValues: [\"30\"],\n      weightInitializationMethod: WeightInitializationMethod.SmallGaussian,\n      previousNetwork: option.none(),\n    }),\n\n    some: (network): NetworkMainMenuState => ({\n      mnist: option.none(),\n\n      stateType: StateType.NetworkMainMenu,\n\n      network,\n    }),\n  });\n}\n\nfunction isPositiveIntStr(s: string): boolean {\n  return Number.isFinite(+s) && +s === Math.floor(+s) && +s > 0;\n}\n\nfunction isPositiveNumStr(s: string): boolean {\n  return Number.isFinite(+s) && +s > 0;\n}\n\nfunction isOnInclusiveUnitInterval(n: number): boolean {\n  return 0 <= n && n <= 1;\n}\n\nfunction getViewedImage(state: ViewState, mnist: MnistData): LabeledImage {\n  return state.viewedIndex < mnist.test.length\n    ? mnist.test[state.viewedIndex]\n    : normalizeU8Image(\n        state.customImages[state.viewedIndex - mnist.test.length]\n      );\n}\n\nfunction normalizeU8Image(image: CustomImage): LabeledImage {\n  return {\n    rows: 28,\n    columns: 28,\n    inputs: image.u8Matrix.immutApplyElementwise((x) => x / 255),\n    label: image.label,\n  };\n}\n\nfunction guessDigit(\n  network: Network,\n  inputs: Matrix\n): { digit: number; confidence: number } {\n  const { activations } = network.performForwardPass(inputs);\n  const outputActivations = activations[\n    activations.length - 1\n  ].rowMajorOrderEntries();\n\n  let maxIndex = 0;\n  let maxConfidence = outputActivations[maxIndex];\n  for (let i = 1; i < outputActivations.length; i++) {\n    const confidence = outputActivations[i];\n    if (confidence > maxConfidence) {\n      maxConfidence = confidence;\n      maxIndex = i;\n    }\n  }\n\n  return { digit: maxIndex, confidence: maxConfidence };\n}\n\nfunction paintImage(image: LabeledImage, canvas: HTMLCanvasElement): void {\n  canvas.width = image.columns;\n  canvas.height = image.rows;\n\n  const ctx = canvas.getContext(\"2d\")!;\n  const imageData = getImageData(image);\n  ctx.putImageData(imageData, 0, 0);\n}\n\nfunction getImageData(image: LabeledImage): ImageData {\n  const entries = image.inputs.rowMajorOrderEntries();\n  const imageBytes = new Uint8ClampedArray(entries.length * 4);\n  for (let i = 0; i < entries.length; i++) {\n    const lightness = 255 - Math.floor(entries[i] * 255);\n    imageBytes[i * 4] = lightness;\n    imageBytes[i * 4 + 1] = lightness;\n    imageBytes[i * 4 + 2] = lightness;\n    imageBytes[i * 4 + 3] = 255;\n  }\n  return new ImageData(imageBytes, image.columns, image.rows);\n}\n\nfunction readFileAsHtmlImage(file: File): Promise<HTMLImageElement> {\n  return readFileAsDataUrl(file).then(\n    (url) =>\n      new Promise((resolve, reject) => {\n        const img = document.createElement(\"img\");\n        img.src = url;\n        img.addEventListener(\"load\", () => resolve(img));\n        img.addEventListener(\"error\", reject);\n      })\n  );\n}\n\nfunction readFileAsDataUrl(file: File): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.addEventListener(\"load\", () => resolve(reader.result as string));\n    reader.addEventListener(\"error\", () => reject(reader.error));\n    reader.readAsDataURL(file);\n  });\n}\n\nconst CropMenuConfig = {\n  OverlayColor: \"#000a\",\n\n  CropSquareColor: \"#08b\",\n  CropSquareLineWidth: 3,\n  GlobalCornerHandleRadius: 10,\n} as const;\n\nfunction paintImageAndCropSquare(\n  image: HTMLImageElement,\n  crop: Square,\n  canvas: HTMLCanvasElement,\n  shouldInvert: boolean,\n  darknessThreshold: number\n): void {\n  canvas.width = image.width;\n  canvas.height = image.height;\n\n  const rect = canvas.getBoundingClientRect();\n  const scale = canvas.width / rect.width;\n\n  const ctx = canvas.getContext(\"2d\")!;\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.drawImage(image, 0, 0);\n\n  if (shouldInvert) {\n    invertContext(ctx);\n  }\n\n  paintOverlay();\n  paintCompressedImage();\n  paintCropSquare();\n\n  return;\n\n  function paintOverlay(): void {\n    const cropBottom = crop.y + crop.size;\n    const cropRight = crop.x + crop.size;\n    ctx.fillStyle = CropMenuConfig.OverlayColor;\n    ctx.fillRect(0, 0, canvas.width, crop.y);\n    ctx.fillRect(0, cropBottom, canvas.width, canvas.height - cropBottom);\n    ctx.fillRect(0, crop.y, crop.x, crop.size);\n    ctx.fillRect(cropRight, crop.y, canvas.width - cropRight, crop.size);\n  }\n\n  function paintCompressedImage(): void {\n    ctx.clearRect(crop.x, crop.y, crop.size, crop.size);\n\n    const compressed = cropAndCompress(\n      image,\n      crop,\n      shouldInvert,\n      darknessThreshold\n    );\n    ctx.imageSmoothingEnabled = false;\n    ctx.drawImage(compressed, crop.x, crop.y, crop.size, crop.size);\n  }\n\n  function paintCropSquare(): void {\n    ctx.strokeStyle = CropMenuConfig.CropSquareColor;\n    ctx.lineWidth = CropMenuConfig.CropSquareLineWidth;\n    ctx.strokeRect(crop.x, crop.y, crop.size, crop.size);\n\n    drawCropSquareCircle(crop.x, crop.y);\n    drawCropSquareCircle(crop.x + crop.size, crop.y);\n    drawCropSquareCircle(crop.x + crop.size, crop.y + crop.size);\n    drawCropSquareCircle(crop.x, crop.y + crop.size);\n  }\n\n  function drawCropSquareCircle(x: number, y: number): void {\n    const localRadius = CropMenuConfig.GlobalCornerHandleRadius * scale;\n    ctx.moveTo(x, y);\n    ctx.beginPath();\n    ctx.arc(x, y, localRadius, 0, 2 * Math.PI);\n    ctx.closePath();\n\n    ctx.fillStyle = CropMenuConfig.CropSquareColor;\n    ctx.fill();\n  }\n}\n\nfunction applyWhiteBackground(srcCtx: CanvasRenderingContext2D): void {\n  const { width, height } = srcCtx.canvas;\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n\n  const ctx = canvas.getContext(\"2d\")!;\n  ctx.fillStyle = \"#ffffff\";\n  ctx.fillRect(0, 0, width, height);\n  ctx.drawImage(srcCtx.canvas, 0, 0);\n\n  const imageData = ctx.getImageData(0, 0, width, height);\n  srcCtx.putImageData(imageData, 0, 0);\n}\n\nfunction getLocalPointerCoordinates(\n  event: React.MouseEvent | React.TouchEvent,\n  canvas: HTMLCanvasElement\n): { x: number; y: number } {\n  const boundingRect = canvas.getBoundingClientRect();\n  const { x, y } = getGlobalPointerCoordinates(event);\n  const xScale = canvas.width / boundingRect.width;\n  const yScale = canvas.height / boundingRect.height;\n  return {\n    x: xScale * (x - boundingRect.left),\n    y: yScale * (y - boundingRect.top),\n  };\n}\n\nfunction getGlobalPointerCoordinates(\n  event: React.MouseEvent | React.TouchEvent\n): { x: number; y: number } {\n  if (\"clientX\" in event) {\n    return { x: event.clientX, y: event.clientY };\n  } else {\n    return { x: event.touches[0].clientX, y: event.touches[0].clientY };\n  }\n}\n\nfunction applyPendingAdjustment(\n  square: Square,\n  adjustment: SquareAdjustment,\n  canvasWidth: number,\n  canvasHeight: number\n): Square {\n  const possiblyOutOfBounds = applyPendingAdjustmentToGetPossiblyOutOfBoundsSquare(\n    square,\n    adjustment\n  );\n  return transformBackIntoBoundsIfNeeded(\n    possiblyOutOfBounds,\n    canvasWidth,\n    canvasHeight,\n    adjustment.dragged === Draggable.EntireSquare\n  );\n}\n\nfunction applyPendingAdjustmentToGetPossiblyOutOfBoundsSquare(\n  square: Square,\n  adjustment: SquareAdjustment\n): Square {\n  if (isCornerAdjustment(adjustment)) {\n    const rect = {\n      x: square.x,\n      y: square.y,\n      width: square.size,\n      height: square.size,\n    };\n    const adjustedRect = applyPendingCornerAdjustmentToRect(rect, adjustment);\n    return clamp(adjustedRect, adjustment.dragged);\n  } else {\n    const dx = adjustment.currentX - adjustment.startX;\n    const dy = adjustment.currentY - adjustment.startY;\n    return applyTranslation(square, dx, dy);\n  }\n}\n\nfunction isCornerAdjustment(\n  adjustment: SquareAdjustment\n): adjustment is CornerAdjustment {\n  return adjustment.dragged !== Draggable.EntireSquare;\n}\n\nfunction applyPendingCornerAdjustmentToRect(\n  rect: Rect,\n  adjustment: CornerAdjustment\n): Rect {\n  const corner = adjustment.dragged;\n  const { currentX, currentY } = adjustment;\n\n  let left = rect.x;\n  let right = rect.x + rect.width;\n  let top = rect.y;\n  let bottom = rect.y + rect.height;\n\n  switch (corner) {\n    case Draggable.TopLeftCorner:\n      top = Math.min(currentY, bottom);\n      left = Math.min(currentX, right);\n      break;\n    case Draggable.TopRightCorner:\n      top = Math.min(currentY, bottom);\n      right = Math.max(currentX, left);\n      break;\n    case Draggable.BottomRightCorner:\n      bottom = Math.max(currentY, top);\n      right = Math.max(currentX, left);\n      break;\n    case Draggable.BottomLeftCorner:\n      bottom = Math.max(currentY, top);\n      left = Math.min(currentX, right);\n      break;\n  }\n\n  if (left > right) {\n    [left, right] = [right, left];\n  }\n  if (top > bottom) {\n    [top, bottom] = [bottom, top];\n  }\n\n  return {\n    x: left,\n    y: top,\n    width: right - left,\n    height: bottom - top,\n  };\n}\n\nfunction clamp(rect: Rect, dragged: Corner): Square {\n  const anchor = getDiagonal(dragged);\n  switch (anchor) {\n    case Draggable.TopLeftCorner:\n      return clampToTopLeft(rect);\n    case Draggable.TopRightCorner:\n      return clampToTopRight(rect);\n    case Draggable.BottomRightCorner:\n      return clampToBottomRight(rect);\n    case Draggable.BottomLeftCorner:\n      return clampToBottomLeft(rect);\n  }\n}\n\nfunction clampToTopLeft(rect: Rect): Square {\n  const { x, y, width, height } = rect;\n  const size = Math.min(width, height);\n  return { x, y, size };\n}\n\nfunction clampToTopRight(rect: Rect): Square {\n  const { x, y, width, height } = rect;\n  const size = Math.min(width, height);\n  return { x: width > height ? x + width - size : x, y, size };\n}\n\nfunction clampToBottomRight(rect: Rect): Square {\n  const { x, y, width, height } = rect;\n  const size = Math.min(width, height);\n  return {\n    x: width > height ? x + width - size : x,\n    y: height > width ? y + height - size : y,\n    size,\n  };\n}\n\nfunction clampToBottomLeft(rect: Rect): Square {\n  const { x, y, width, height } = rect;\n  const size = Math.min(width, height);\n  return { x, y: height > width ? y + height - size : y, size };\n}\n\nfunction getDiagonal(corner: Corner): Corner {\n  switch (corner) {\n    case Draggable.TopLeftCorner:\n      return Draggable.BottomRightCorner;\n    case Draggable.TopRightCorner:\n      return Draggable.BottomLeftCorner;\n    case Draggable.BottomRightCorner:\n      return Draggable.TopLeftCorner;\n    case Draggable.BottomLeftCorner:\n      return Draggable.TopRightCorner;\n  }\n}\n\nfunction applyTranslation(square: Square, dx: number, dy: number): Square {\n  return { x: square.x + dx, y: square.y + dy, size: square.size };\n}\n\nfunction getHoveredOverDraggable(\n  square: Square,\n  x: number,\n  y: number,\n  localRadius: number\n): Option<Draggable> {\n  if (Math.hypot(x - square.x, y - square.y) <= localRadius) {\n    return option.some(Draggable.TopLeftCorner);\n  } else if (\n    Math.hypot(x - (square.x + square.size), y - square.y) <= localRadius\n  ) {\n    return option.some(Draggable.TopRightCorner);\n  } else if (\n    Math.hypot(x - (square.x + square.size), y - (square.y + square.size)) <=\n    localRadius\n  ) {\n    return option.some(Draggable.BottomRightCorner);\n  } else if (\n    Math.hypot(x - square.x, y - (square.y + square.size)) <= localRadius\n  ) {\n    return option.some(Draggable.BottomLeftCorner);\n  } else if (\n    x > square.x &&\n    x < square.x + square.size &&\n    y > square.y &&\n    y < square.y + square.size\n  ) {\n    return option.some(Draggable.EntireSquare);\n  } else {\n    return option.none();\n  }\n}\n\nfunction transformBackIntoBoundsIfNeeded(\n  square: Square,\n  width: number,\n  height: number,\n  preserveSize: boolean\n): Square {\n  if (preserveSize) {\n    const { x, y, size } = square;\n\n    const maxX = width - size;\n    const maxY = height - size;\n\n    return {\n      x: Math.max(0, Math.min(x, maxX)),\n      y: Math.max(0, Math.min(y, maxY)),\n      size,\n    };\n  } else {\n    let { x, y, size } = square;\n\n    x = Math.max(0, Math.min(x, width));\n    y = Math.max(0, Math.min(y, height));\n\n    const maxSize = Math.min(width - x, height - y);\n    size = Math.min(size, maxSize);\n\n    return { x, y, size };\n  }\n}\n\nfunction cropAndCompress(\n  image: HTMLImageElement,\n  crop: Square,\n  shouldInvert: boolean,\n  darknessThreshold: number\n): HTMLCanvasElement {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 28;\n  canvas.height = 28;\n\n  const ctx = canvas.getContext(\"2d\")!;\n  ctx.drawImage(image, crop.x, crop.y, crop.size, crop.size, 0, 0, 28, 28);\n\n  applyGrayscale(ctx);\n\n  if (shouldInvert) {\n    invertContext(ctx);\n  }\n\n  applyDarknessThreshold(ctx, darknessThreshold);\n\n  return canvas;\n}\n\nfunction invertContext(ctx: CanvasRenderingContext2D): void {\n  const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);\n  const bytes = imageData.data;\n  for (let i = 0; i < bytes.length; i += 4) {\n    bytes[i] = 255 - bytes[i];\n    bytes[i + 1] = 255 - bytes[i + 1];\n    bytes[i + 2] = 255 - bytes[i + 2];\n  }\n  ctx.putImageData(imageData, 0, 0);\n}\n\nfunction applyGrayscale(ctx: CanvasRenderingContext2D): void {\n  const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);\n  const pixels = imageData.data;\n  for (let i = 0; i < pixels.length; i += 4) {\n    const averageLightness = Math.floor(\n      (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3\n    );\n    pixels[i] = averageLightness;\n    pixels[i + 1] = averageLightness;\n    pixels[i + 2] = averageLightness;\n  }\n  ctx.putImageData(imageData, 0, 0);\n}\n\nfunction applyDarknessThreshold(\n  ctx: CanvasRenderingContext2D,\n  darknessThreshold: number\n): void {\n  const lightnessThreshold = 1 - darknessThreshold;\n  const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);\n  const pixels = imageData.data;\n  for (let i = 0; i < pixels.length; i += 4) {\n    const averageLightness = Math.floor(\n      (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3\n    );\n    const normalizedLightness = averageLightness / 255;\n    const roundedLightness = normalizedLightness < lightnessThreshold ? 0 : 255;\n    pixels[i] = roundedLightness;\n    pixels[i + 1] = roundedLightness;\n    pixels[i + 2] = roundedLightness;\n  }\n  ctx.putImageData(imageData, 0, 0);\n}\n\nfunction isDigit(s: string): boolean {\n  return /^\\d$/.test(s);\n}\n\nfunction getCustomImage(\n  state: CropState,\n  label: number,\n  shouldInvert: boolean,\n  darknessThreshold: number\n): CustomImage {\n  const { cropSquare, uploadedImage } = state;\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = 28;\n  canvas.height = 28;\n\n  const ctx = canvas.getContext(\"2d\")!;\n\n  ctx.imageSmoothingEnabled = false;\n  ctx.drawImage(\n    uploadedImage,\n    cropSquare.x,\n    cropSquare.y,\n    cropSquare.size,\n    cropSquare.size,\n    0,\n    0,\n    28,\n    28\n  );\n\n  if (shouldInvert) {\n    invertContext(ctx);\n  }\n\n  applyWhiteBackground(ctx);\n\n  const u8Matrix = getU8Matrix(\n    ctx.getImageData(0, 0, 28, 28),\n    darknessThreshold\n  );\n  return { u8Matrix, label };\n}\n\nfunction getU8Matrix(imageData: ImageData, darknessThreshold: number): Matrix {\n  const lightnessThreshold = 1 - darknessThreshold;\n\n  const { data } = imageData;\n  const u8s = new Array(data.length / 4);\n  for (let i = 0; i < data.length; i += 4) {\n    const averageLightness = Math.floor(\n      (data[i] + data[i + 1] + data[i + 2]) / 3\n    );\n    const normalizedLightness = averageLightness / 255;\n    const roundedLightness = normalizedLightness < lightnessThreshold ? 0 : 255;\n    const roundedDarkness = 255 - roundedLightness;\n    u8s[i / 4] = roundedDarkness;\n  }\n  return Matrix.columnVector(u8s);\n}\n\n/** Returns a float between 0 and 1. */\nfunction getAverageDarkness(image: HTMLImageElement): number {\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = image.width;\n  canvas.height = image.height;\n\n  const ctx = canvas.getContext(\"2d\")!;\n\n  ctx.fillStyle = \"#ffffff\";\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n  ctx.drawImage(image, 0, 0);\n\n  const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n  let totalLightness = 0;\n  for (let i = 0; i < pixels.length; i += 4) {\n    const lightness = Math.floor(\n      (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3\n    );\n    totalLightness += lightness;\n  }\n  const numberOfPixels = pixels.length / 4;\n  const averageLightness = Math.floor(totalLightness / numberOfPixels);\n  const averageDarkness = 255 - averageLightness;\n  return averageDarkness / 255;\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport \"./index.css\";\nimport { networkFactory } from \"./network/networkFactory\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\n(window as any).networkFactory = networkFactory;\n"],"sourceRoot":""}